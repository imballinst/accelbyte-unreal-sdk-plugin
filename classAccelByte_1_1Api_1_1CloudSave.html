<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: AccelByte::Api::CloudSave Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classAccelByte_1_1Api_1_1CloudSave.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classAccelByte_1_1Api_1_1CloudSave-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">AccelByte::Api::CloudSave Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classAccelByte_1_1Api_1_1CloudSave.html" title="CloudSave API for storing records.">CloudSave</a> API for storing records.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="AccelByteCloudSaveApi_8h_source.html">AccelByteCloudSaveApi.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for AccelByte::Api::CloudSave:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classAccelByte_1_1Api_1_1CloudSave.png" usemap="#AccelByte::Api::CloudSave_map" alt=""/>
  <map id="AccelByte::Api::CloudSave_map" name="AccelByte::Api::CloudSave_map">
<area href="classAccelByte_1_1FApiBase.html" alt="AccelByte::FApiBase" shape="rect" coords="0,0,163,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a58fe4e1652bc30e5b2941ea35f5d854a" id="r_a58fe4e1652bc30e5b2941ea35f5d854a"><td class="memItemLeft" align="right" valign="top"><a id="a58fe4e1652bc30e5b2941ea35f5d854a" name="a58fe4e1652bc30e5b2941ea35f5d854a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CloudSave</b> (<a class="el" href="classAccelByte_1_1Credentials.html">Credentials</a> const &amp;InCredentialsRef, <a class="el" href="classAccelByte_1_1Settings.html">Settings</a> const &amp;InSettingsRef, <a class="el" href="classAccelByte_1_1FHttpRetryScheduler.html">FHttpRetryScheduler</a> &amp;InHttpRef)</td></tr>
<tr class="separator:a58fe4e1652bc30e5b2941ea35f5d854a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64722bc77c3e6522a685134797d97bc9" id="r_a64722bc77c3e6522a685134797d97bc9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64722bc77c3e6522a685134797d97bc9">SaveUserRecord</a> (const FString &amp;Key, bool bSetPublic, const FJsonObject &amp;RecordRequest, const FVoidHandler &amp;OnSuccess, const FErrorHandler &amp;OnError)</td></tr>
<tr class="memdesc:a64722bc77c3e6522a685134797d97bc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save a user-level record with Metadata input value.  <br /></td></tr>
<tr class="separator:a64722bc77c3e6522a685134797d97bc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37d6e95a93f2885685b19cff798665ad" id="r_a37d6e95a93f2885685b19cff798665ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a37d6e95a93f2885685b19cff798665ad">SaveUserRecord</a> (FString const &amp;Key, FJsonObject RecordRequest, bool IsPublic, FVoidHandler const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a37d6e95a93f2885685b19cff798665ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save a user-level record. If the record doesn't exist, it will create and save the record, if already exists, it will append to the existing one.  <br /></td></tr>
<tr class="separator:a37d6e95a93f2885685b19cff798665ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86c3118dd6b4ad1b5c46f7a889ff50f7" id="r_a86c3118dd6b4ad1b5c46f7a889ff50f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a86c3118dd6b4ad1b5c46f7a889ff50f7">GetUserRecord</a> (FString const &amp;Key, THandler&lt; <a class="el" href="structFAccelByteModelsUserRecord.html">FAccelByteModelsUserRecord</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a86c3118dd6b4ad1b5c46f7a889ff50f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a record (arbitrary JSON data) by its key in user-level.  <br /></td></tr>
<tr class="separator:a86c3118dd6b4ad1b5c46f7a889ff50f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bf693b78dace91b3c364d16fdd994f3" id="r_a9bf693b78dace91b3c364d16fdd994f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9bf693b78dace91b3c364d16fdd994f3">GetPublicUserRecord</a> (FString const &amp;Key, FString const &amp;UserId, THandler&lt; <a class="el" href="structFAccelByteModelsUserRecord.html">FAccelByteModelsUserRecord</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a9bf693b78dace91b3c364d16fdd994f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a public record (arbitrary JSON data) by its key and userId in user-level.  <br /></td></tr>
<tr class="separator:a9bf693b78dace91b3c364d16fdd994f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fc9942cb5be6bf6f95e87a0ab89ec25" id="r_a2fc9942cb5be6bf6f95e87a0ab89ec25"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2fc9942cb5be6bf6f95e87a0ab89ec25">BulkGetPublicUserRecord</a> (FString const &amp;Key, const TArray&lt; FString &gt; &amp;UserIds, THandler&lt; <a class="el" href="structFListAccelByteModelsUserRecord.html">FListAccelByteModelsUserRecord</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a2fc9942cb5be6bf6f95e87a0ab89ec25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a public record (arbitrary JSON data) by its key and userId in user-level.  <br /></td></tr>
<tr class="separator:a2fc9942cb5be6bf6f95e87a0ab89ec25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad40a07c0a661d9b5ad7c7756870f2047" id="r_ad40a07c0a661d9b5ad7c7756870f2047"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad40a07c0a661d9b5ad7c7756870f2047">BulkGetUserRecords</a> (TArray&lt; FString &gt; const &amp;Keys, THandler&lt; <a class="el" href="structFListAccelByteModelsUserRecord.html">FListAccelByteModelsUserRecord</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:ad40a07c0a661d9b5ad7c7756870f2047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bulk get records (arbitrary JSON data) by list of keys.  <br /></td></tr>
<tr class="separator:ad40a07c0a661d9b5ad7c7756870f2047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0588c4062cc5a9b9044c32e71657c698" id="r_a0588c4062cc5a9b9044c32e71657c698"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0588c4062cc5a9b9044c32e71657c698">ReplaceUserRecord</a> (const FString &amp;Key, bool bSetPublic, const FJsonObject &amp;RecordRequest, const FVoidHandler &amp;OnSuccess, const FErrorHandler &amp;OnError)</td></tr>
<tr class="memdesc:a0588c4062cc5a9b9044c32e71657c698"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace a record in user-level. If the record doesn't exist, it will create and save the record. If already exists, it will replace the existing one.  <br /></td></tr>
<tr class="separator:a0588c4062cc5a9b9044c32e71657c698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a356819ab0eb6dc76fbc6cff33cdd5028" id="r_a356819ab0eb6dc76fbc6cff33cdd5028"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a356819ab0eb6dc76fbc6cff33cdd5028">ReplaceUserRecord</a> (FString const &amp;Key, FJsonObject RecordRequest, bool IsPublic, FVoidHandler const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a356819ab0eb6dc76fbc6cff33cdd5028"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace a record in user-level. If the record doesn't exist, it will create and save the record. If already exists, it will replace the existing one.  <br /></td></tr>
<tr class="separator:a356819ab0eb6dc76fbc6cff33cdd5028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21888e2731a3afde9f24f506a0ccc143" id="r_a21888e2731a3afde9f24f506a0ccc143"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a21888e2731a3afde9f24f506a0ccc143">ReplaceUserRecordCheckLatest</a> (FString const &amp;Key, FDateTime const LastUpdated, FJsonObjectWrapper RecordRequest, FVoidHandler const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a21888e2731a3afde9f24f506a0ccc143"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace a record in user-level. If the record doesn't exist, it will create and save the record. If already exists, it will replace the existing one, but will failed if lastUpdated is not up-to-date.  <br /></td></tr>
<tr class="separator:a21888e2731a3afde9f24f506a0ccc143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70aa54b396a37fe3b18448767af6b79b" id="r_a70aa54b396a37fe3b18448767af6b79b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a70aa54b396a37fe3b18448767af6b79b">ReplaceUserRecordCheckLatest</a> (int TryAttempt, FString const &amp;Key, FJsonObjectWrapper RecordRequest, THandlerPayloadModifier&lt; FJsonObjectWrapper, FJsonObjectWrapper &gt; const &amp;PayloadModifier, FVoidHandler const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a70aa54b396a37fe3b18448767af6b79b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace a record in user-level. If the record doesn't exist, it will create and save the record. If already exists, it will replace the existing one. Beware: Function will try to get the latest value, put it in the custom modifier and request to replace the record. will retry it again when the record is updated by other user, until exhaust all the attempt.  <br /></td></tr>
<tr class="separator:a70aa54b396a37fe3b18448767af6b79b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a9e256e5091e9259ac07210a19525bb" id="r_a9a9e256e5091e9259ac07210a19525bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9a9e256e5091e9259ac07210a19525bb">ReplaceUserRecordCheckLatest</a> (FString const &amp;Key, FDateTime LastUpdated, FJsonObjectWrapper RecordRequest, THandler&lt; <a class="el" href="structFAccelByteModelsReplaceUserRecordResponse.html">FAccelByteModelsReplaceUserRecordResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a9a9e256e5091e9259ac07210a19525bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace a record in user-level. If the record doesn't exist, it will create and save the record. If already exists, it will replace the existing one, but will failed if lastUpdated is not up-to-date.  <br /></td></tr>
<tr class="separator:a9a9e256e5091e9259ac07210a19525bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf2f24afa7137ca39cccdc7ddeac10be" id="r_aaf2f24afa7137ca39cccdc7ddeac10be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf2f24afa7137ca39cccdc7ddeac10be">ReplaceUserRecordCheckLatest</a> (int TryAttempt, FString const &amp;Key, FJsonObjectWrapper RecordRequest, THandlerPayloadModifier&lt; FJsonObjectWrapper, FJsonObjectWrapper &gt; const &amp;PayloadModifier, THandler&lt; <a class="el" href="structFAccelByteModelsReplaceUserRecordResponse.html">FAccelByteModelsReplaceUserRecordResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:aaf2f24afa7137ca39cccdc7ddeac10be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace a record in user-level. If the record doesn't exist, it will create and save the record. If already exists, it will replace the existing one. Beware: Function will try to get the latest value, put it in the custom modifier and request to replace the record. will retry it again when the record is updated by other user, until exhaust all the attempt.  <br /></td></tr>
<tr class="separator:aaf2f24afa7137ca39cccdc7ddeac10be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81cd205f41f92c33deac92c3d8565e9e" id="r_a81cd205f41f92c33deac92c3d8565e9e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a81cd205f41f92c33deac92c3d8565e9e">DeleteUserRecord</a> (FString const &amp;Key, FVoidHandler const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a81cd205f41f92c33deac92c3d8565e9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a record under the given key in user-level.  <br /></td></tr>
<tr class="separator:a81cd205f41f92c33deac92c3d8565e9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ae6d6282a16bacd6a563f4bce50a449" id="r_a5ae6d6282a16bacd6a563f4bce50a449"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ae6d6282a16bacd6a563f4bce50a449">SaveGameRecord</a> (FString const &amp;Key, FJsonObject RecordRequest, FVoidHandler const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a5ae6d6282a16bacd6a563f4bce50a449"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save a namespace-level record. If the record doesn't exist, it will create and save the record, if already exists, it will append to the existing one.  <br /></td></tr>
<tr class="separator:a5ae6d6282a16bacd6a563f4bce50a449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1645414614ca5144d520e3fa795c774a" id="r_a1645414614ca5144d520e3fa795c774a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1645414614ca5144d520e3fa795c774a">GetGameRecord</a> (FString const &amp;Key, THandler&lt; <a class="el" href="structFAccelByteModelsGameRecord.html">FAccelByteModelsGameRecord</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a1645414614ca5144d520e3fa795c774a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a record by its key in namespace-level.  <br /></td></tr>
<tr class="separator:a1645414614ca5144d520e3fa795c774a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecaae3b9d5daf97c392b6fbf0f3850f7" id="r_aecaae3b9d5daf97c392b6fbf0f3850f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aecaae3b9d5daf97c392b6fbf0f3850f7">ReplaceGameRecord</a> (FString const &amp;Key, FJsonObject RecordRequest, FVoidHandler const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:aecaae3b9d5daf97c392b6fbf0f3850f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace a record in namespace-level. If the record doesn't exist, it will create and save the record. If already exists, it will replace the existing one.  <br /></td></tr>
<tr class="separator:aecaae3b9d5daf97c392b6fbf0f3850f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e15b274587541b27d33367d740b24d0" id="r_a1e15b274587541b27d33367d740b24d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1e15b274587541b27d33367d740b24d0">ReplaceGameRecordCheckLatest</a> (FString const &amp;Key, FDateTime const LastUpdated, FJsonObjectWrapper RecordRequest, FVoidHandler const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a1e15b274587541b27d33367d740b24d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace a record in namespace-level. If the record doesn't exist, it will create and save the record. If already exists, it will replace the existing one, but will failed if lastUpdated is not up-to-date.  <br /></td></tr>
<tr class="separator:a1e15b274587541b27d33367d740b24d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d0a0bbbba86b9b55bf6d43ccdb21b1c" id="r_a8d0a0bbbba86b9b55bf6d43ccdb21b1c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d0a0bbbba86b9b55bf6d43ccdb21b1c">ReplaceGameRecordCheckLatest</a> (int TryAttempt, FString const &amp;Key, FJsonObjectWrapper RecordRequest, THandlerPayloadModifier&lt; FJsonObjectWrapper, FJsonObjectWrapper &gt; const &amp;PayloadModifier, FVoidHandler const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a8d0a0bbbba86b9b55bf6d43ccdb21b1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace a record in namespace-level. If the record doesn't exist, it will create and save the record. If already exists, it will replace the existing one. Beware: Function will try to get the latest value, put it in the custom modifier and request to replace the record. will retry it again when the record is updated by other user, until exhaust all the attempt.  <br /></td></tr>
<tr class="separator:a8d0a0bbbba86b9b55bf6d43ccdb21b1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aa4b3908198afde8e17807af67ebc71" id="r_a9aa4b3908198afde8e17807af67ebc71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9aa4b3908198afde8e17807af67ebc71">DeleteGameRecord</a> (FString const &amp;Key, FVoidHandler const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a9aa4b3908198afde8e17807af67ebc71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a record under the given key in namespace-level.  <br /></td></tr>
<tr class="separator:a9aa4b3908198afde8e17807af67ebc71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb0e3d0c1fb61307c44b2f7cc6590ca6" id="r_adb0e3d0c1fb61307c44b2f7cc6590ca6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adb0e3d0c1fb61307c44b2f7cc6590ca6">BulkGetGameRecords</a> (TArray&lt; FString &gt; const &amp;Keys, THandler&lt; <a class="el" href="structFAccelByteModelsListGameRecords.html">FAccelByteModelsListGameRecords</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:adb0e3d0c1fb61307c44b2f7cc6590ca6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bulk get game records (arbitrary JSON data) by list of keys.  <br /></td></tr>
<tr class="separator:adb0e3d0c1fb61307c44b2f7cc6590ca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fae67bed20f1dc0018ebecfe44bd03d" id="r_a2fae67bed20f1dc0018ebecfe44bd03d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2fae67bed20f1dc0018ebecfe44bd03d">BulkGetOtherPlayerPublicRecordKeys</a> (FString const &amp;UserId, THandler&lt; <a class="el" href="structFAccelByteModelsPaginatedBulkGetPublicUserRecordKeysResponse.html">FAccelByteModelsPaginatedBulkGetPublicUserRecordKeysResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError, int32 const &amp;Offset=0, int32 const &amp;Limit=20)</td></tr>
<tr class="memdesc:a2fae67bed20f1dc0018ebecfe44bd03d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the public key record for a user in bulk.  <br /></td></tr>
<tr class="separator:a2fae67bed20f1dc0018ebecfe44bd03d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5de7089482566e440955b605e1485011" id="r_a5de7089482566e440955b605e1485011"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5de7089482566e440955b605e1485011">BulkGetOtherPlayerPublicRecords</a> (FString const &amp;UserId, TArray&lt; FString &gt; const &amp;Keys, THandler&lt; <a class="el" href="structFListAccelByteModelsUserRecord.html">FListAccelByteModelsUserRecord</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a5de7089482566e440955b605e1485011"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the public record for a user in bulk using public keys.  <br /></td></tr>
<tr class="separator:a5de7089482566e440955b605e1485011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classAccelByte_1_1FApiBase"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_classAccelByte_1_1FApiBase')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classAccelByte_1_1FApiBase.html">AccelByte::FApiBase</a></td></tr>
<tr class="memitem:ac408a88edb62afa5bb1cbfe388fb7ada inherit pub_methods_classAccelByte_1_1FApiBase" id="r_ac408a88edb62afa5bb1cbfe388fb7ada"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>FApiBase</b> (<a class="el" href="classAccelByte_1_1Credentials.html">Credentials</a> const &amp;InCredentialsRef, <a class="el" href="classAccelByte_1_1Settings.html">Settings</a> const &amp;InSettingsRef, <a class="el" href="classAccelByte_1_1FHttpRetryScheduler.html">FHttpRetryScheduler</a> &amp;InHttpRef)</td></tr>
<tr class="separator:ac408a88edb62afa5bb1cbfe388fb7ada inherit pub_methods_classAccelByte_1_1FApiBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classAccelByte_1_1FApiBase"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_methods_classAccelByte_1_1FApiBase')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classAccelByte_1_1FApiBase.html">AccelByte::FApiBase</a></td></tr>
<tr class="memitem:abf73c69f11a74c5d79ed767d7e9de861 inherit pro_methods_classAccelByte_1_1FApiBase" id="r_abf73c69f11a74c5d79ed767d7e9de861"><td class="memTemplParams" colspan="2">
template&lt;typename T &gt; </td></tr>
<tr class="memitem:abf73c69f11a74c5d79ed767d7e9de861 inherit pro_methods_classAccelByte_1_1FApiBase"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ValidateAccelByteId</b> (FString const &amp;Id, EAccelByteIdHypensRule HypenRule, FString const &amp;ErrorMessage, T const &amp;OnError)</td></tr>
<tr class="separator:abf73c69f11a74c5d79ed767d7e9de861 inherit pro_methods_classAccelByte_1_1FApiBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classAccelByte_1_1FApiBase"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_attribs_classAccelByte_1_1FApiBase')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classAccelByte_1_1FApiBase.html">AccelByte::FApiBase</a></td></tr>
<tr class="memitem:a585cbf945993a436bb4447c8d6635be5 inherit pro_attribs_classAccelByte_1_1FApiBase" id="r_a585cbf945993a436bb4447c8d6635be5"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classAccelByte_1_1Credentials.html">Credentials</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>CredentialsRef</b></td></tr>
<tr class="separator:a585cbf945993a436bb4447c8d6635be5 inherit pro_attribs_classAccelByte_1_1FApiBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8ffc36382a4204edb20a6d3430c13ad inherit pro_attribs_classAccelByte_1_1FApiBase" id="r_ae8ffc36382a4204edb20a6d3430c13ad"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classAccelByte_1_1Settings.html">Settings</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>SettingsRef</b></td></tr>
<tr class="separator:ae8ffc36382a4204edb20a6d3430c13ad inherit pro_attribs_classAccelByte_1_1FApiBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be9ff9374ca90ae6cb787c74837d85f inherit pro_attribs_classAccelByte_1_1FApiBase" id="r_a8be9ff9374ca90ae6cb787c74837d85f"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classAccelByte_1_1FHttpRetryScheduler.html">FHttpRetryScheduler</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>HttpRef</b></td></tr>
<tr class="separator:a8be9ff9374ca90ae6cb787c74837d85f inherit pro_attribs_classAccelByte_1_1FApiBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd2ef10eecc71f4d34515276ab6a8fcb inherit pro_attribs_classAccelByte_1_1FApiBase" id="r_afd2ef10eecc71f4d34515276ab6a8fcb"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classAccelByte_1_1FHttpClient.html">FHttpClient</a>&#160;</td><td class="memItemRight" valign="bottom"><b>HttpClient</b></td></tr>
<tr class="separator:afd2ef10eecc71f4d34515276ab6a8fcb inherit pro_attribs_classAccelByte_1_1FApiBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classAccelByte_1_1Api_1_1CloudSave.html" title="CloudSave API for storing records.">CloudSave</a> API for storing records. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="adb0e3d0c1fb61307c44b2f7cc6590ca6" name="adb0e3d0c1fb61307c44b2f7cc6590ca6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb0e3d0c1fb61307c44b2f7cc6590ca6">&#9670;&#160;</a></span>BulkGetGameRecords()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::CloudSave::BulkGetGameRecords </td>
          <td>(</td>
          <td class="paramtype">TArray&lt; FString &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>Keys</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="structFAccelByteModelsListGameRecords.html">FAccelByteModelsListGameRecords</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bulk get game records (arbitrary JSON data) by list of keys. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Keys</td><td>List Key of record. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is const <a class="el" href="structFAccelByteModelsListGameRecords.html">FAccelByteModelsListGameRecords</a>&amp;. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2fae67bed20f1dc0018ebecfe44bd03d" name="a2fae67bed20f1dc0018ebecfe44bd03d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fae67bed20f1dc0018ebecfe44bd03d">&#9670;&#160;</a></span>BulkGetOtherPlayerPublicRecordKeys()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::CloudSave::BulkGetOtherPlayerPublicRecordKeys </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>UserId</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="structFAccelByteModelsPaginatedBulkGetPublicUserRecordKeysResponse.html">FAccelByteModelsPaginatedBulkGetPublicUserRecordKeysResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32 const &amp;</td>          <td class="paramname"><span class="paramname"><em>Offset</em><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32 const &amp;</td>          <td class="paramname"><span class="paramname"><em>Limit</em><span class="paramdefsep"> = </span><span class="paramdefval">20</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the public key record for a user in bulk. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">UserId</td><td>UserId of the keys owner. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is const <a class="el" href="structFAccelByteModelsPaginatedBulkGetPublicUserRecordKeysResponse.html">FAccelByteModelsPaginatedBulkGetPublicUserRecordKeysResponse</a>&amp;. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
    <tr><td class="paramname">Offset</td><td>The offset of the cloudsave result. Default value is 0. </td></tr>
    <tr><td class="paramname">Limit</td><td>The limit of the cloudsave result. Default value is 20. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5de7089482566e440955b605e1485011" name="a5de7089482566e440955b605e1485011"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5de7089482566e440955b605e1485011">&#9670;&#160;</a></span>BulkGetOtherPlayerPublicRecords()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::CloudSave::BulkGetOtherPlayerPublicRecords </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>UserId</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TArray&lt; FString &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>Keys</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="structFListAccelByteModelsUserRecord.html">FListAccelByteModelsUserRecord</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the public record for a user in bulk using public keys. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">UserId</td><td>UserId of the keys owner. </td></tr>
    <tr><td class="paramname">Keys</td><td>List Key of record. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is const <a class="el" href="structFListAccelByteModelsUserRecord.html">FListAccelByteModelsUserRecord</a>&amp;. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2fc9942cb5be6bf6f95e87a0ab89ec25" name="a2fc9942cb5be6bf6f95e87a0ab89ec25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fc9942cb5be6bf6f95e87a0ab89ec25">&#9670;&#160;</a></span>BulkGetPublicUserRecord()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::CloudSave::BulkGetPublicUserRecord </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>Key</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TArray&lt; FString &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>UserIds</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="structFListAccelByteModelsUserRecord.html">FListAccelByteModelsUserRecord</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a public record (arbitrary JSON data) by its key and userId in user-level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Key</td><td>Key of record. </td></tr>
    <tr><td class="paramname">UserIds</td><td>List UserId(s) of the record owner. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is const <a class="el" href="structFAccelByteModelsUserRecord.html">FAccelByteModelsUserRecord</a>&amp;. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad40a07c0a661d9b5ad7c7756870f2047" name="ad40a07c0a661d9b5ad7c7756870f2047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad40a07c0a661d9b5ad7c7756870f2047">&#9670;&#160;</a></span>BulkGetUserRecords()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::CloudSave::BulkGetUserRecords </td>
          <td>(</td>
          <td class="paramtype">TArray&lt; FString &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>Keys</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="structFListAccelByteModelsUserRecord.html">FListAccelByteModelsUserRecord</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bulk get records (arbitrary JSON data) by list of keys. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Keys</td><td>List Key of record. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is const <a class="el" href="structFAccelByteModelsUserRecord.html">FAccelByteModelsUserRecord</a>&amp;. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9aa4b3908198afde8e17807af67ebc71" name="a9aa4b3908198afde8e17807af67ebc71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aa4b3908198afde8e17807af67ebc71">&#9670;&#160;</a></span>DeleteGameRecord()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::CloudSave::DeleteGameRecord </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>Key</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FVoidHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a record under the given key in namespace-level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Key</td><td>Key of record. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a81cd205f41f92c33deac92c3d8565e9e" name="a81cd205f41f92c33deac92c3d8565e9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81cd205f41f92c33deac92c3d8565e9e">&#9670;&#160;</a></span>DeleteUserRecord()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::CloudSave::DeleteUserRecord </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>Key</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FVoidHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a record under the given key in user-level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Key</td><td>Key of record. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1645414614ca5144d520e3fa795c774a" name="a1645414614ca5144d520e3fa795c774a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1645414614ca5144d520e3fa795c774a">&#9670;&#160;</a></span>GetGameRecord()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::CloudSave::GetGameRecord </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>Key</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="structFAccelByteModelsGameRecord.html">FAccelByteModelsGameRecord</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a record by its key in namespace-level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Key</td><td>Key of record. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is const <a class="el" href="structFAccelByteModelsGameRecord.html">FAccelByteModelsGameRecord</a>&amp;. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9bf693b78dace91b3c364d16fdd994f3" name="a9bf693b78dace91b3c364d16fdd994f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bf693b78dace91b3c364d16fdd994f3">&#9670;&#160;</a></span>GetPublicUserRecord()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::CloudSave::GetPublicUserRecord </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>Key</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>UserId</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="structFAccelByteModelsUserRecord.html">FAccelByteModelsUserRecord</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a public record (arbitrary JSON data) by its key and userId in user-level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Key</td><td>Key of record. </td></tr>
    <tr><td class="paramname">UserId</td><td>UserId of the record owner. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is const <a class="el" href="structFAccelByteModelsUserRecord.html">FAccelByteModelsUserRecord</a>&amp;. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a86c3118dd6b4ad1b5c46f7a889ff50f7" name="a86c3118dd6b4ad1b5c46f7a889ff50f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86c3118dd6b4ad1b5c46f7a889ff50f7">&#9670;&#160;</a></span>GetUserRecord()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::CloudSave::GetUserRecord </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>Key</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="structFAccelByteModelsUserRecord.html">FAccelByteModelsUserRecord</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a record (arbitrary JSON data) by its key in user-level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Key</td><td>Key of record. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is const <a class="el" href="structFAccelByteModelsUserRecord.html">FAccelByteModelsUserRecord</a>&amp;. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aecaae3b9d5daf97c392b6fbf0f3850f7" name="aecaae3b9d5daf97c392b6fbf0f3850f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecaae3b9d5daf97c392b6fbf0f3850f7">&#9670;&#160;</a></span>ReplaceGameRecord()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::CloudSave::ReplaceGameRecord </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>Key</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FJsonObject</td>          <td class="paramname"><span class="paramname"><em>RecordRequest</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FVoidHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace a record in namespace-level. If the record doesn't exist, it will create and save the record. If already exists, it will replace the existing one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Key</td><td>Key of record. </td></tr>
    <tr><td class="paramname">RecordRequest</td><td>The request of the record with JSON formatted. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1e15b274587541b27d33367d740b24d0" name="a1e15b274587541b27d33367d740b24d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e15b274587541b27d33367d740b24d0">&#9670;&#160;</a></span>ReplaceGameRecordCheckLatest() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::CloudSave::ReplaceGameRecordCheckLatest </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>Key</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FDateTime const</td>          <td class="paramname"><span class="paramname"><em>LastUpdated</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FJsonObjectWrapper</td>          <td class="paramname"><span class="paramname"><em>RecordRequest</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FVoidHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace a record in namespace-level. If the record doesn't exist, it will create and save the record. If already exists, it will replace the existing one, but will failed if lastUpdated is not up-to-date. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Key</td><td>Key of record. </td></tr>
    <tr><td class="paramname">LastUpdated</td><td>last time the record is updated. Retrieve it from GetGameRecord. </td></tr>
    <tr><td class="paramname">RecordRequest</td><td>The request of the record with JSON formatted. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d0a0bbbba86b9b55bf6d43ccdb21b1c" name="a8d0a0bbbba86b9b55bf6d43ccdb21b1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d0a0bbbba86b9b55bf6d43ccdb21b1c">&#9670;&#160;</a></span>ReplaceGameRecordCheckLatest() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::CloudSave::ReplaceGameRecordCheckLatest </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>TryAttempt</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>Key</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FJsonObjectWrapper</td>          <td class="paramname"><span class="paramname"><em>RecordRequest</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandlerPayloadModifier&lt; FJsonObjectWrapper, FJsonObjectWrapper &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>PayloadModifier</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FVoidHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace a record in namespace-level. If the record doesn't exist, it will create and save the record. If already exists, it will replace the existing one. Beware: Function will try to get the latest value, put it in the custom modifier and request to replace the record. will retry it again when the record is updated by other user, until exhaust all the attempt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">TryAttempt</td><td>Attempt to try to replace the game record. </td></tr>
    <tr><td class="paramname">Key</td><td>Key of record. </td></tr>
    <tr><td class="paramname">RecordRequest</td><td>The request of the record with JSON formatted. </td></tr>
    <tr><td class="paramname">PayloadModifier</td><td>Function to modify the latest record value with your customized modifier. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0588c4062cc5a9b9044c32e71657c698" name="a0588c4062cc5a9b9044c32e71657c698"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0588c4062cc5a9b9044c32e71657c698">&#9670;&#160;</a></span>ReplaceUserRecord() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::CloudSave::ReplaceUserRecord </td>
          <td>(</td>
          <td class="paramtype">const FString &amp;</td>          <td class="paramname"><span class="paramname"><em>Key</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>bSetPublic</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FJsonObject &amp;</td>          <td class="paramname"><span class="paramname"><em>RecordRequest</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FVoidHandler &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FErrorHandler &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace a record in user-level. If the record doesn't exist, it will create and save the record. If already exists, it will replace the existing one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Key</td><td>Key of record. </td></tr>
    <tr><td class="paramname">SetPublic</td><td>Metadata is_public value and set by client </td></tr>
    <tr><td class="paramname">RecordRequest</td><td>The request of the record with JSON formatted. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a356819ab0eb6dc76fbc6cff33cdd5028" name="a356819ab0eb6dc76fbc6cff33cdd5028"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a356819ab0eb6dc76fbc6cff33cdd5028">&#9670;&#160;</a></span>ReplaceUserRecord() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::CloudSave::ReplaceUserRecord </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>Key</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FJsonObject</td>          <td class="paramname"><span class="paramname"><em>RecordRequest</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>IsPublic</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FVoidHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace a record in user-level. If the record doesn't exist, it will create and save the record. If already exists, it will replace the existing one. </p>
<p>The end point of this method if bIsPublic is true (using suffix /public) will be deprecated in future <br  />
 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Key</td><td>Key of record. </td></tr>
    <tr><td class="paramname">RecordRequest</td><td>The request of the record with JSON formatted. </td></tr>
    <tr><td class="paramname">IsPublic</td><td>Save the record as a public/private record. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a21888e2731a3afde9f24f506a0ccc143" name="a21888e2731a3afde9f24f506a0ccc143"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21888e2731a3afde9f24f506a0ccc143">&#9670;&#160;</a></span>ReplaceUserRecordCheckLatest() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::CloudSave::ReplaceUserRecordCheckLatest </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>Key</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FDateTime const</td>          <td class="paramname"><span class="paramname"><em>LastUpdated</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FJsonObjectWrapper</td>          <td class="paramname"><span class="paramname"><em>RecordRequest</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FVoidHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace a record in user-level. If the record doesn't exist, it will create and save the record. If already exists, it will replace the existing one, but will failed if lastUpdated is not up-to-date. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Key</td><td>Key of record. </td></tr>
    <tr><td class="paramname">LastUpdated</td><td>last time the record is updated. Retrieve it from GetGameRecord. </td></tr>
    <tr><td class="paramname">RecordRequest</td><td>The request of the record with JSON formatted. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9a9e256e5091e9259ac07210a19525bb" name="a9a9e256e5091e9259ac07210a19525bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a9e256e5091e9259ac07210a19525bb">&#9670;&#160;</a></span>ReplaceUserRecordCheckLatest() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::CloudSave::ReplaceUserRecordCheckLatest </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>Key</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FDateTime</td>          <td class="paramname"><span class="paramname"><em>LastUpdated</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FJsonObjectWrapper</td>          <td class="paramname"><span class="paramname"><em>RecordRequest</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="structFAccelByteModelsReplaceUserRecordResponse.html">FAccelByteModelsReplaceUserRecordResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace a record in user-level. If the record doesn't exist, it will create and save the record. If already exists, it will replace the existing one, but will failed if lastUpdated is not up-to-date. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Key</td><td>Key of record. </td></tr>
    <tr><td class="paramname">LastUpdated</td><td>last time the record is updated. Retrieve it from GetGameRecord. </td></tr>
    <tr><td class="paramname">RecordRequest</td><td>The request of the record with JSON formatted. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is const <a class="el" href="structFAccelByteModelsReplaceUserRecordResponse.html">FAccelByteModelsReplaceUserRecordResponse</a>. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a70aa54b396a37fe3b18448767af6b79b" name="a70aa54b396a37fe3b18448767af6b79b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70aa54b396a37fe3b18448767af6b79b">&#9670;&#160;</a></span>ReplaceUserRecordCheckLatest() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::CloudSave::ReplaceUserRecordCheckLatest </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>TryAttempt</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>Key</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FJsonObjectWrapper</td>          <td class="paramname"><span class="paramname"><em>RecordRequest</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandlerPayloadModifier&lt; FJsonObjectWrapper, FJsonObjectWrapper &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>PayloadModifier</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FVoidHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace a record in user-level. If the record doesn't exist, it will create and save the record. If already exists, it will replace the existing one. Beware: Function will try to get the latest value, put it in the custom modifier and request to replace the record. will retry it again when the record is updated by other user, until exhaust all the attempt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">TryAttempt</td><td>Attempt to try to replace the game record. </td></tr>
    <tr><td class="paramname">Key</td><td>Key of record. </td></tr>
    <tr><td class="paramname">RecordRequest</td><td>The request of the record with JSON formatted. </td></tr>
    <tr><td class="paramname">PayloadModifier</td><td>Function to modify the latest record value with your customized modifier. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaf2f24afa7137ca39cccdc7ddeac10be" name="aaf2f24afa7137ca39cccdc7ddeac10be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf2f24afa7137ca39cccdc7ddeac10be">&#9670;&#160;</a></span>ReplaceUserRecordCheckLatest() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::CloudSave::ReplaceUserRecordCheckLatest </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>TryAttempt</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>Key</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FJsonObjectWrapper</td>          <td class="paramname"><span class="paramname"><em>RecordRequest</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandlerPayloadModifier&lt; FJsonObjectWrapper, FJsonObjectWrapper &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>PayloadModifier</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="structFAccelByteModelsReplaceUserRecordResponse.html">FAccelByteModelsReplaceUserRecordResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace a record in user-level. If the record doesn't exist, it will create and save the record. If already exists, it will replace the existing one. Beware: Function will try to get the latest value, put it in the custom modifier and request to replace the record. will retry it again when the record is updated by other user, until exhaust all the attempt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">TryAttempt</td><td>Attempt to try to replace the game record. </td></tr>
    <tr><td class="paramname">Key</td><td>Key of record. </td></tr>
    <tr><td class="paramname">RecordRequest</td><td>The request of the record with JSON formatted. </td></tr>
    <tr><td class="paramname">PayloadModifier</td><td>Function to modify the latest record value with your customized modifier. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is const <a class="el" href="structFAccelByteModelsReplaceUserRecordResponse.html">FAccelByteModelsReplaceUserRecordResponse</a>. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5ae6d6282a16bacd6a563f4bce50a449" name="a5ae6d6282a16bacd6a563f4bce50a449"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ae6d6282a16bacd6a563f4bce50a449">&#9670;&#160;</a></span>SaveGameRecord()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::CloudSave::SaveGameRecord </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>Key</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FJsonObject</td>          <td class="paramname"><span class="paramname"><em>RecordRequest</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FVoidHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save a namespace-level record. If the record doesn't exist, it will create and save the record, if already exists, it will append to the existing one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Key</td><td>Key of record. </td></tr>
    <tr><td class="paramname">RecordRequest</td><td>The request of the record with JSON formatted. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a64722bc77c3e6522a685134797d97bc9" name="a64722bc77c3e6522a685134797d97bc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64722bc77c3e6522a685134797d97bc9">&#9670;&#160;</a></span>SaveUserRecord() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::CloudSave::SaveUserRecord </td>
          <td>(</td>
          <td class="paramtype">const FString &amp;</td>          <td class="paramname"><span class="paramname"><em>Key</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>bSetPublic</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FJsonObject &amp;</td>          <td class="paramname"><span class="paramname"><em>RecordRequest</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FVoidHandler &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FErrorHandler &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save a user-level record with Metadata input value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Key</td><td>Key of record. </td></tr>
    <tr><td class="paramname">SetPublic</td><td>Metadata is_public value and set by client </td></tr>
    <tr><td class="paramname">RecordRequest</td><td>The request of the record with JSON formatted. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a37d6e95a93f2885685b19cff798665ad" name="a37d6e95a93f2885685b19cff798665ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37d6e95a93f2885685b19cff798665ad">&#9670;&#160;</a></span>SaveUserRecord() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::CloudSave::SaveUserRecord </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>Key</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FJsonObject</td>          <td class="paramname"><span class="paramname"><em>RecordRequest</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>IsPublic</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FVoidHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save a user-level record. If the record doesn't exist, it will create and save the record, if already exists, it will append to the existing one. </p>
<p>The end point of this method if bIsPublic is true (using suffix /public) will be deprecated in future <br  />
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Key</td><td>Key of record. </td></tr>
    <tr><td class="paramname">RecordRequest</td><td>The request of the record with JSON formatted. </td></tr>
    <tr><td class="paramname">IsPublic</td><td>Save the record as a public/private record. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>Source/AccelByteUe4Sdk/Public/Api/<a class="el" href="AccelByteCloudSaveApi_8h_source.html">AccelByteCloudSaveApi.h</a></li>
<li>Source/AccelByteUe4Sdk/Private/Api/<b>AccelByteCloudSaveApi.cpp</b></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>AccelByte</b></li><li class="navelem"><a class="el" href="namespaceAccelByte_1_1Api.html">Api</a></li><li class="navelem"><a class="el" href="classAccelByte_1_1Api_1_1CloudSave.html">CloudSave</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0 </li>
  </ul>
</div>
</body>
</html>
