<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: AccelByte::Api::UGC Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classAccelByte_1_1Api_1_1UGC.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classAccelByte_1_1Api_1_1UGC-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">AccelByte::Api::UGC Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Provide APIs to access <a class="el" href="classAccelByte_1_1Api_1_1UGC.html" title="Provide APIs to access UGC service.">UGC</a> service.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="AccelByteUGCApi_8h_source.html">AccelByteUGCApi.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for AccelByte::Api::UGC:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classAccelByte_1_1Api_1_1UGC.png" usemap="#AccelByte::Api::UGC_map" alt=""/>
  <map id="AccelByte::Api::UGC_map" name="AccelByte::Api::UGC_map">
<area href="classAccelByte_1_1FApiBase.html" alt="AccelByte::FApiBase" shape="rect" coords="0,0,131,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a979bc447256c14ac582bde530fd3b9f7" id="r_a979bc447256c14ac582bde530fd3b9f7"><td class="memItemLeft" align="right" valign="top"><a id="a979bc447256c14ac582bde530fd3b9f7" name="a979bc447256c14ac582bde530fd3b9f7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>UGC</b> (<a class="el" href="classAccelByte_1_1Credentials.html">Credentials</a> const &amp;InCredentialsRef, <a class="el" href="classAccelByte_1_1Settings.html">Settings</a> const &amp;InSettingsRef, <a class="el" href="classAccelByte_1_1FHttpRetryScheduler.html">FHttpRetryScheduler</a> &amp;InHttpRef)</td></tr>
<tr class="separator:a979bc447256c14ac582bde530fd3b9f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc43f7665279b314fd26989290b38dd2" id="r_adc43f7665279b314fd26989290b38dd2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adc43f7665279b314fd26989290b38dd2">CreateContent</a> (FString const &amp;ChannelId, <a class="el" href="structFAccelByteModelsUGCRequest.html">FAccelByteModelsUGCRequest</a> const &amp;UGCRequest, THandler&lt; <a class="el" href="structFAccelByteModelsUGCResponse.html">FAccelByteModelsUGCResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:adc43f7665279b314fd26989290b38dd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a content with FString preview and get the payload url to upload the content.  <br /></td></tr>
<tr class="separator:adc43f7665279b314fd26989290b38dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f9c5eacc22ac41dac341e54d407e06e" id="r_a8f9c5eacc22ac41dac341e54d407e06e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8f9c5eacc22ac41dac341e54d407e06e">CreateContent</a> (FString const &amp;ChannelId, FString const &amp;Name, FString const &amp;Type, FString const &amp;SubType, TArray&lt; FString &gt; const &amp;Tags, TArray&lt; uint8 &gt; const &amp;Preview, FString const &amp;FileExtension, THandler&lt; <a class="el" href="structFAccelByteModelsUGCResponse.html">FAccelByteModelsUGCResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError, FString ContentType=TEXT(&quot;application/octet-stream&quot;))</td></tr>
<tr class="memdesc:a8f9c5eacc22ac41dac341e54d407e06e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a content with TArray&lt;uint8&gt; Preview parameter and get the payload url to upload the content.  <br /></td></tr>
<tr class="separator:a8f9c5eacc22ac41dac341e54d407e06e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5777743df8b7caec13600e3c2887bea" id="r_af5777743df8b7caec13600e3c2887bea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af5777743df8b7caec13600e3c2887bea">ModifyContent</a> (FString const &amp;ChannelId, FString const &amp;ContentId, <a class="el" href="structFAccelByteModelsUGCUpdateRequest.html">FAccelByteModelsUGCUpdateRequest</a> const &amp;ModifyRequest, THandler&lt; <a class="el" href="structFAccelByteModelsUGCResponse.html">FAccelByteModelsUGCResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:af5777743df8b7caec13600e3c2887bea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify existing content to update some information with FString preview.  <br /></td></tr>
<tr class="separator:af5777743df8b7caec13600e3c2887bea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9361686cc3672d828f0f5fecbce2a827" id="r_a9361686cc3672d828f0f5fecbce2a827"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9361686cc3672d828f0f5fecbce2a827">ModifyContent</a> (FString const &amp;ChannelId, FString const &amp;ContentId, <a class="el" href="structFAccelByteModelsUGCRequest.html">FAccelByteModelsUGCRequest</a> const &amp;UGCRequest, THandler&lt; <a class="el" href="structFAccelByteModelsUGCResponse.html">FAccelByteModelsUGCResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError, bool bUpdateContent=false)</td></tr>
<tr class="memdesc:a9361686cc3672d828f0f5fecbce2a827"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify existing content to update some information with FString preview.  <br /></td></tr>
<tr class="separator:a9361686cc3672d828f0f5fecbce2a827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdc2d804b418e4707b23a6a6d61d665f" id="r_afdc2d804b418e4707b23a6a6d61d665f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afdc2d804b418e4707b23a6a6d61d665f">ModifyContent</a> (FString const &amp;ChannelId, FString const &amp;ContentId, FString const &amp;Name, FString const &amp;Type, FString const &amp;SubType, TArray&lt; FString &gt; const &amp;Tags, TArray&lt; uint8 &gt; const &amp;Preview, FString const &amp;FileExtension, THandler&lt; <a class="el" href="structFAccelByteModelsUGCResponse.html">FAccelByteModelsUGCResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError, FString ContentType=TEXT(&quot;application/octet-stream&quot;), bool bUpdateContent=false)</td></tr>
<tr class="memdesc:afdc2d804b418e4707b23a6a6d61d665f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify existing content to update some information with TArray&lt;uint8&gt; Preview parameter.  <br /></td></tr>
<tr class="separator:afdc2d804b418e4707b23a6a6d61d665f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f0acae6dfbe5c05eadff9135b8fb02e" id="r_a0f0acae6dfbe5c05eadff9135b8fb02e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0f0acae6dfbe5c05eadff9135b8fb02e">DeleteContent</a> (FString const &amp;ChannelId, FString const &amp;ContentId, FVoidHandler const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a0f0acae6dfbe5c05eadff9135b8fb02e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a content based on the its channel id and content id.  <br /></td></tr>
<tr class="separator:a0f0acae6dfbe5c05eadff9135b8fb02e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60e8e41dac74635a6daa89904745928c" id="r_a60e8e41dac74635a6daa89904745928c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a60e8e41dac74635a6daa89904745928c">GetContentByContentId</a> (FString const &amp;ContentId, THandler&lt; <a class="el" href="structFAccelByteModelsUGCContentResponse.html">FAccelByteModelsUGCContentResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a60e8e41dac74635a6daa89904745928c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a content information by its content id.  <br /></td></tr>
<tr class="separator:a60e8e41dac74635a6daa89904745928c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09af8284b1d56eaa5318c1e89b8b4cee" id="r_a09af8284b1d56eaa5318c1e89b8b4cee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a09af8284b1d56eaa5318c1e89b8b4cee">PublicGetContentByContentId</a> (FString const &amp;ContentId, THandler&lt; <a class="el" href="structFAccelByteModelsUGCContentResponse.html">FAccelByteModelsUGCContentResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a09af8284b1d56eaa5318c1e89b8b4cee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a content information by its content id. Can be used without logged in.  <br /></td></tr>
<tr class="separator:a09af8284b1d56eaa5318c1e89b8b4cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a631fd51106a81ea412a9f73a11c62250" id="r_a631fd51106a81ea412a9f73a11c62250"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a631fd51106a81ea412a9f73a11c62250">GetContentByShareCode</a> (FString const &amp;ShareCode, THandler&lt; <a class="el" href="structFAccelByteModelsUGCContentResponse.html">FAccelByteModelsUGCContentResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a631fd51106a81ea412a9f73a11c62250"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a content information by its share code.  <br /></td></tr>
<tr class="separator:a631fd51106a81ea412a9f73a11c62250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7ac4204f3dd657187cef760ddf86493" id="r_af7ac4204f3dd657187cef760ddf86493"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af7ac4204f3dd657187cef760ddf86493">PublicGetContentByShareCode</a> (FString const &amp;ShareCode, THandler&lt; <a class="el" href="structFAccelByteModelsUGCContentResponse.html">FAccelByteModelsUGCContentResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:af7ac4204f3dd657187cef760ddf86493"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a content information by its share code. Can be used without logged in.  <br /></td></tr>
<tr class="separator:af7ac4204f3dd657187cef760ddf86493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac94a8448a3c8fd897e6512c961ee6ba1" id="r_ac94a8448a3c8fd897e6512c961ee6ba1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac94a8448a3c8fd897e6512c961ee6ba1">GetContentPreview</a> (FString const &amp;ContentId, THandler&lt; <a class="el" href="structFAccelByteModelsUGCPreview.html">FAccelByteModelsUGCPreview</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:ac94a8448a3c8fd897e6512c961ee6ba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get content Preview as <a class="el" href="structFAccelByteModelsUGCPreview.html">FAccelByteModelsUGCPreview</a>.  <br /></td></tr>
<tr class="separator:ac94a8448a3c8fd897e6512c961ee6ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a252c44da0b3a0d54aef9c9f666c7ac3e" id="r_a252c44da0b3a0d54aef9c9f666c7ac3e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a252c44da0b3a0d54aef9c9f666c7ac3e">GetContentPreview</a> (FString const &amp;ContentId, THandler&lt; TArray&lt; uint8 &gt; &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a252c44da0b3a0d54aef9c9f666c7ac3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get content preview as TArray&lt;uint8&gt;.  <br /></td></tr>
<tr class="separator:a252c44da0b3a0d54aef9c9f666c7ac3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2237fd43368c8b8d87ff386555b482f" id="r_ab2237fd43368c8b8d87ff386555b482f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab2237fd43368c8b8d87ff386555b482f">GetTags</a> (THandler&lt; <a class="el" href="structFAccelByteModelsUGCTagsPagingResponse.html">FAccelByteModelsUGCTagsPagingResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError, int32 Limit=1000, int32 Offset=0)</td></tr>
<tr class="memdesc:ab2237fd43368c8b8d87ff386555b482f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all tags.  <br /></td></tr>
<tr class="separator:ab2237fd43368c8b8d87ff386555b482f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a924a3dc5109d08ef581df907d64dbe74" id="r_a924a3dc5109d08ef581df907d64dbe74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a924a3dc5109d08ef581df907d64dbe74">GetTypes</a> (THandler&lt; <a class="el" href="structFAccelByteModelsUGCTypesPagingResponse.html">FAccelByteModelsUGCTypesPagingResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError, int32 Limit=1000, int32 Offset=0)</td></tr>
<tr class="memdesc:a924a3dc5109d08ef581df907d64dbe74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all types and subtypes.  <br /></td></tr>
<tr class="separator:a924a3dc5109d08ef581df907d64dbe74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a122877c1a060ed3389d75e554e5e79" id="r_a4a122877c1a060ed3389d75e554e5e79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a122877c1a060ed3389d75e554e5e79">CreateChannel</a> (FString const &amp;ChannelName, THandler&lt; <a class="el" href="structFAccelByteModelsUGCChannelResponse.html">FAccelByteModelsUGCChannelResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a4a122877c1a060ed3389d75e554e5e79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a player's channel with specific channel name.  <br /></td></tr>
<tr class="separator:a4a122877c1a060ed3389d75e554e5e79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39e5986744921b67750f8c2831908979" id="r_a39e5986744921b67750f8c2831908979"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a39e5986744921b67750f8c2831908979">UpdateChannel</a> (FString const &amp;ChannelId, FString const &amp;ChannelName, THandler&lt; <a class="el" href="structFAccelByteModelsUGCChannelResponse.html">FAccelByteModelsUGCChannelResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a39e5986744921b67750f8c2831908979"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update a player's channel with specific channel name.  <br /></td></tr>
<tr class="separator:a39e5986744921b67750f8c2831908979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79d576353f7c74513e5f09fb263416da" id="r_a79d576353f7c74513e5f09fb263416da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a79d576353f7c74513e5f09fb263416da">GetChannels</a> (THandler&lt; <a class="el" href="structFAccelByteModelsUGCChannelsPagingResponse.html">FAccelByteModelsUGCChannelsPagingResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError, int32 Limit=1000, int32 Offset=0, FString const &amp;ChannelName=&quot;&quot;)</td></tr>
<tr class="memdesc:a79d576353f7c74513e5f09fb263416da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all of the player's channels.  <br /></td></tr>
<tr class="separator:a79d576353f7c74513e5f09fb263416da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3cd61400775c3c1f946d7282a197efa" id="r_af3cd61400775c3c1f946d7282a197efa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af3cd61400775c3c1f946d7282a197efa">GetChannels</a> (FString const &amp;UserId, THandler&lt; <a class="el" href="structFAccelByteModelsUGCChannelsPagingResponse.html">FAccelByteModelsUGCChannelsPagingResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError, int32 Limit=1000, int32 Offset=0, FString const &amp;ChannelName=&quot;&quot;)</td></tr>
<tr class="memdesc:af3cd61400775c3c1f946d7282a197efa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all of the player's channels.  <br /></td></tr>
<tr class="separator:af3cd61400775c3c1f946d7282a197efa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80d1b20440cc4ec12d1bbffbf96b5140" id="r_a80d1b20440cc4ec12d1bbffbf96b5140"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a80d1b20440cc4ec12d1bbffbf96b5140">DeleteChannel</a> (FString const &amp;ChannelId, FVoidHandler const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a80d1b20440cc4ec12d1bbffbf96b5140"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a player's channel based on the its channel id.  <br /></td></tr>
<tr class="separator:a80d1b20440cc4ec12d1bbffbf96b5140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3063ff832866492c4e3b0ccb4c4faef" id="r_ae3063ff832866492c4e3b0ccb4c4faef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae3063ff832866492c4e3b0ccb4c4faef">SearchContents</a> (const FString &amp;Name, const FString &amp;Creator, const FString &amp;Type, const FString &amp;Subtype, const TArray&lt; FString &gt; &amp;Tags, bool IsOfficial, const FString &amp;UserId, THandler&lt; <a class="el" href="structFAccelByteModelsUGCSearchContentsPagingResponse.html">FAccelByteModelsUGCSearchContentsPagingResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError, EAccelByteUgcSortBy SortBy=EAccelByteUgcSortBy::DATE, EAccelByteUgcOrderBy OrderBy=EAccelByteUgcOrderBy::DESC, int32 Limit=1000, int32 Offset=0)</td></tr>
<tr class="memdesc:ae3063ff832866492c4e3b0ccb4c4faef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search specific contents based on the given filter.  <br /></td></tr>
<tr class="separator:ae3063ff832866492c4e3b0ccb4c4faef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30e7d643b2d73f4a7503811986d73220" id="r_a30e7d643b2d73f4a7503811986d73220"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a30e7d643b2d73f4a7503811986d73220">SearchContents</a> (<a class="el" href="structFAccelByteModelsUGCSearchContentsRequest.html">FAccelByteModelsUGCSearchContentsRequest</a> const &amp;Request, THandler&lt; <a class="el" href="structFAccelByteModelsUGCSearchContentsPagingResponse.html">FAccelByteModelsUGCSearchContentsPagingResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError, int32 Limit=20, int32 Offset=0)</td></tr>
<tr class="memdesc:a30e7d643b2d73f4a7503811986d73220"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search specific contents based on the given filter.  <br /></td></tr>
<tr class="separator:a30e7d643b2d73f4a7503811986d73220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6a980705fc7b788403099dbbb797581" id="r_ac6a980705fc7b788403099dbbb797581"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac6a980705fc7b788403099dbbb797581">PublicSearchContents</a> (const FString &amp;Name, const FString &amp;Creator, const FString &amp;Type, const FString &amp;Subtype, const TArray&lt; FString &gt; &amp;Tags, bool IsOfficial, const FString &amp;UserId, THandler&lt; <a class="el" href="structFAccelByteModelsUGCSearchContentsPagingResponse.html">FAccelByteModelsUGCSearchContentsPagingResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError, EAccelByteUgcSortBy SortBy=EAccelByteUgcSortBy::DATE, EAccelByteUgcOrderBy OrderBy=EAccelByteUgcOrderBy::DESC, int32 Limit=1000, int32 Offset=0)</td></tr>
<tr class="memdesc:ac6a980705fc7b788403099dbbb797581"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search specific contents based on the given filter. Can be used without logged in.  <br /></td></tr>
<tr class="separator:ac6a980705fc7b788403099dbbb797581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac87ddff889bfdb2e2d9d0d2f0b986e8b" id="r_ac87ddff889bfdb2e2d9d0d2f0b986e8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac87ddff889bfdb2e2d9d0d2f0b986e8b">PublicSearchContents</a> (<a class="el" href="structFAccelByteModelsUGCSearchContentsRequest.html">FAccelByteModelsUGCSearchContentsRequest</a> const &amp;Request, THandler&lt; <a class="el" href="structFAccelByteModelsUGCSearchContentsPagingResponse.html">FAccelByteModelsUGCSearchContentsPagingResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError, int32 Limit=20, int32 Offset=0)</td></tr>
<tr class="memdesc:ac87ddff889bfdb2e2d9d0d2f0b986e8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search specific contents based on the given filter. Can be used without logged in.  <br /></td></tr>
<tr class="separator:ac87ddff889bfdb2e2d9d0d2f0b986e8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ae14e910608e33cdd75ffe314500e41" id="r_a3ae14e910608e33cdd75ffe314500e41"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3ae14e910608e33cdd75ffe314500e41">UpdateLikeStatusToContent</a> (const FString &amp;ContentId, bool bLikeStatus, THandler&lt; <a class="el" href="structFAccelByteModelsUGCUpdateLikeStatusToContentResponse.html">FAccelByteModelsUGCUpdateLikeStatusToContentResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a3ae14e910608e33cdd75ffe314500e41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update like/unlike status to a content.  <br /></td></tr>
<tr class="separator:a3ae14e910608e33cdd75ffe314500e41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac52e981ec4d1dc2b65cafb17a30d8388" id="r_ac52e981ec4d1dc2b65cafb17a30d8388"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac52e981ec4d1dc2b65cafb17a30d8388">GetListFollowers</a> (const FString &amp;UserId, THandler&lt; <a class="el" href="structFAccelByteModelsUGCGetListFollowersPagingResponse.html">FAccelByteModelsUGCGetListFollowersPagingResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError, int32 Limit=1000, int32 Offset=0)</td></tr>
<tr class="memdesc:ac52e981ec4d1dc2b65cafb17a30d8388"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get list of followers.  <br /></td></tr>
<tr class="separator:ac52e981ec4d1dc2b65cafb17a30d8388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af937490e74168b5a76dddf5ba74766f4" id="r_af937490e74168b5a76dddf5ba74766f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af937490e74168b5a76dddf5ba74766f4">UpdateFollowStatusToUser</a> (const FString &amp;UserId, bool bFollowStatus, THandler&lt; <a class="el" href="structFAccelByteModelsUGCUpdateFollowStatusToUserResponse.html">FAccelByteModelsUGCUpdateFollowStatusToUserResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:af937490e74168b5a76dddf5ba74766f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update follow/unfollow status to a user.  <br /></td></tr>
<tr class="separator:af937490e74168b5a76dddf5ba74766f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cca87c6528d665d51ab7ab2855dac99" id="r_a9cca87c6528d665d51ab7ab2855dac99"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9cca87c6528d665d51ab7ab2855dac99">SearchContentsSpecificToChannel</a> (const FString &amp;ChannelId, const FString &amp;Name, const FString &amp;Creator, const FString &amp;Type, const FString &amp;Subtype, const TArray&lt; FString &gt; &amp;Tags, bool IsOfficial, const FString &amp;UserId, THandler&lt; <a class="el" href="structFAccelByteModelsUGCSearchContentsPagingResponse.html">FAccelByteModelsUGCSearchContentsPagingResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError, EAccelByteUgcSortBy SortBy=EAccelByteUgcSortBy::DATE, EAccelByteUgcOrderBy OrderBy=EAccelByteUgcOrderBy::DESC, int32 Limit=1000, int32 Offset=0)</td></tr>
<tr class="memdesc:a9cca87c6528d665d51ab7ab2855dac99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search contents specific to a channel. <br  />
  <br /></td></tr>
<tr class="separator:a9cca87c6528d665d51ab7ab2855dac99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b52538045aecada33275e0bee56a5c6" id="r_a3b52538045aecada33275e0bee56a5c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b52538045aecada33275e0bee56a5c6">SearchContentsSpecificToChannel</a> (FString const &amp;ChannelId, <a class="el" href="structFAccelByteModelsUGCSearchContentsRequest.html">FAccelByteModelsUGCSearchContentsRequest</a> const &amp;Request, THandler&lt; <a class="el" href="structFAccelByteModelsUGCSearchContentsPagingResponse.html">FAccelByteModelsUGCSearchContentsPagingResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError, int32 Limit=20, int32 Offset=0)</td></tr>
<tr class="memdesc:a3b52538045aecada33275e0bee56a5c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search contents specific to a channel.  <br /></td></tr>
<tr class="separator:a3b52538045aecada33275e0bee56a5c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f4332ffb4f9852bc753444ec0c02b36" id="r_a5f4332ffb4f9852bc753444ec0c02b36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f4332ffb4f9852bc753444ec0c02b36">GetContentBulk</a> (const TArray&lt; FString &gt; &amp;ContentIds, THandler&lt; TArray&lt; <a class="el" href="structFAccelByteModelsUGCContentResponse.html">FAccelByteModelsUGCContentResponse</a> &gt; &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a5f4332ffb4f9852bc753444ec0c02b36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get contents by content Ids.  <br /></td></tr>
<tr class="separator:a5f4332ffb4f9852bc753444ec0c02b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa287172c58f70b3c5ac338607a647d67" id="r_aa287172c58f70b3c5ac338607a647d67"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa287172c58f70b3c5ac338607a647d67">PublicGetContentBulk</a> (const TArray&lt; FString &gt; &amp;ContentIds, THandler&lt; TArray&lt; <a class="el" href="structFAccelByteModelsUGCContentResponse.html">FAccelByteModelsUGCContentResponse</a> &gt; &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:aa287172c58f70b3c5ac338607a647d67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get contents by content Ids. Can be used without logged in.  <br /></td></tr>
<tr class="separator:aa287172c58f70b3c5ac338607a647d67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07b3af8b155767c6f49768121fdc7b89" id="r_a07b3af8b155767c6f49768121fdc7b89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a07b3af8b155767c6f49768121fdc7b89">GetUserContent</a> (const FString &amp;UserId, THandler&lt; <a class="el" href="structFAccelByteModelsUGCContentPageResponse.html">FAccelByteModelsUGCContentPageResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError, int32 Limit=1000, int32 Offset=0)</td></tr>
<tr class="memdesc:a07b3af8b155767c6f49768121fdc7b89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get user's generated contents.  <br /></td></tr>
<tr class="separator:a07b3af8b155767c6f49768121fdc7b89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b06508637e6eedcda19e7ec2cfe48f3" id="r_a2b06508637e6eedcda19e7ec2cfe48f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b06508637e6eedcda19e7ec2cfe48f3">PublicGetUserContent</a> (const FString &amp;UserId, THandler&lt; <a class="el" href="structFAccelByteModelsUGCContentPageResponse.html">FAccelByteModelsUGCContentPageResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError, int32 Limit=1000, int32 Offset=0)</td></tr>
<tr class="memdesc:a2b06508637e6eedcda19e7ec2cfe48f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get user's generated contents. Can be used without logged in.  <br /></td></tr>
<tr class="separator:a2b06508637e6eedcda19e7ec2cfe48f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a343386299199e87c311475f366f5bf02" id="r_a343386299199e87c311475f366f5bf02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a343386299199e87c311475f366f5bf02">UploadContentScreenshot</a> (const FString &amp;ContentId, const FString &amp;UserId, <a class="el" href="structFAccelByteModelsUGCScreenshotsRequest.html">FAccelByteModelsUGCScreenshotsRequest</a> ScreenshotsRequest, THandler&lt; <a class="el" href="structFAccelByteModelsUGCUpdateContentScreenshotResponse.html">FAccelByteModelsUGCUpdateContentScreenshotResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a343386299199e87c311475f366f5bf02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Upload screenshots for content. <br  />
  <br /></td></tr>
<tr class="separator:a343386299199e87c311475f366f5bf02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3730c7c330d38fa439988e358ffdaec" id="r_aa3730c7c330d38fa439988e358ffdaec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa3730c7c330d38fa439988e358ffdaec">GetFollowedContent</a> (THandler&lt; <a class="el" href="structFAccelByteModelsUGCContentPageResponse.html">FAccelByteModelsUGCContentPageResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError, int32 Limit=1000, int32 Offset=0)</td></tr>
<tr class="memdesc:aa3730c7c330d38fa439988e358ffdaec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get contents from followed creators.  <br /></td></tr>
<tr class="separator:aa3730c7c330d38fa439988e358ffdaec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0686e5f56eeda4aa075443e78a6cf963" id="r_a0686e5f56eeda4aa075443e78a6cf963"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0686e5f56eeda4aa075443e78a6cf963">GetFollowedUsers</a> (THandler&lt; <a class="el" href="structFAccelByteModelsUGCFollowedUsersResponse.html">FAccelByteModelsUGCFollowedUsersResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError, int32 Limit=1000, int32 Offset=0)</td></tr>
<tr class="memdesc:a0686e5f56eeda4aa075443e78a6cf963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get followed creators. <br  />
  <br /></td></tr>
<tr class="separator:a0686e5f56eeda4aa075443e78a6cf963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68d8b0dfe63fff3b5e66a031cbb6c1d2" id="r_a68d8b0dfe63fff3b5e66a031cbb6c1d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a68d8b0dfe63fff3b5e66a031cbb6c1d2">GetLikedContent</a> (const TArray&lt; FString &gt; &amp;Tags, const FString &amp;Name, const FString &amp;Type, const FString &amp;Subtype, bool IsOfficial, THandler&lt; <a class="el" href="structFAccelByteModelsUGCContentPageResponse.html">FAccelByteModelsUGCContentPageResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError, int32 Limit=1000, int32 Offset=0, EAccelByteUgcSortBy SortBy=EAccelByteUgcSortBy::DATE, EAccelByteUgcOrderBy OrderBy=EAccelByteUgcOrderBy::DESC)</td></tr>
<tr class="memdesc:a68d8b0dfe63fff3b5e66a031cbb6c1d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get liked contents. <br  />
  <br /></td></tr>
<tr class="separator:a68d8b0dfe63fff3b5e66a031cbb6c1d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af19c1605d7005e8f268afa3b212eb55f" id="r_af19c1605d7005e8f268afa3b212eb55f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af19c1605d7005e8f268afa3b212eb55f">GetLikedContent</a> (const TArray&lt; FString &gt; &amp;Tags, const FString &amp;Name, const FString &amp;Type, const FString &amp;Subtype, bool IsOfficial, THandler&lt; <a class="el" href="structFAccelByteModelsUGCContentPageResponse.html">FAccelByteModelsUGCContentPageResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError, int32 Limit=1000, int32 Offset=0, EAccelByteLikedContentSortBy SortBy=EAccelByteLikedContentSortBy::DATE, EAccelByteUgcOrderBy OrderBy=EAccelByteUgcOrderBy::DESC)</td></tr>
<tr class="memdesc:af19c1605d7005e8f268afa3b212eb55f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get liked contents. <br  />
  <br /></td></tr>
<tr class="separator:af19c1605d7005e8f268afa3b212eb55f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5de01684b1b296cfedf9f9ca8cdcf418" id="r_a5de01684b1b296cfedf9f9ca8cdcf418"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5de01684b1b296cfedf9f9ca8cdcf418">GetCreator</a> (const FString &amp;UserId, THandler&lt; <a class="el" href="structFAccelByteModelsUGCGetListFollowersResponse.html">FAccelByteModelsUGCGetListFollowersResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a5de01684b1b296cfedf9f9ca8cdcf418"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get creator stats: number of total like by other user, number of total following and follower user. <br  />
  <br /></td></tr>
<tr class="separator:a5de01684b1b296cfedf9f9ca8cdcf418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa944239e28ca2b65baeeb00713626e74" id="r_aa944239e28ca2b65baeeb00713626e74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa944239e28ca2b65baeeb00713626e74">GetGroups</a> (const FString &amp;UserId, THandler&lt; <a class="el" href="structFAccelByteModelsUGCGetGroupsResponse.html">FAccelByteModelsUGCGetGroupsResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError, int32 Limit=1000, int32 Offset=0)</td></tr>
<tr class="memdesc:aa944239e28ca2b65baeeb00713626e74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all user groups.  <br /></td></tr>
<tr class="separator:aa944239e28ca2b65baeeb00713626e74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1204f672cfcfdca674de9b44b5a0d68" id="r_ac1204f672cfcfdca674de9b44b5a0d68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac1204f672cfcfdca674de9b44b5a0d68">BulkGetContentByShareCode</a> (const TArray&lt; FString &gt; &amp;ShareCodes, THandler&lt; TArray&lt; <a class="el" href="structFAccelByteModelsUGCContentResponse.html">FAccelByteModelsUGCContentResponse</a> &gt; &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:ac1204f672cfcfdca674de9b44b5a0d68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bulk Get contents by ShareCodes.  <br /></td></tr>
<tr class="separator:ac1204f672cfcfdca674de9b44b5a0d68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77e73a112397ca7e936cb1fa0a67fcf7" id="r_a77e73a112397ca7e936cb1fa0a67fcf7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a77e73a112397ca7e936cb1fa0a67fcf7">SearchContentsSpecificToChannelV2</a> (FString const &amp;ChannelId, THandler&lt; <a class="el" href="structFAccelByteModelsUGCSearchContentsPagingResponseV2.html">FAccelByteModelsUGCSearchContentsPagingResponseV2</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError, int32 Limit=20, int32 Offset=0, EAccelByteUGCContentUtilitiesSortByV2 SortBy=EAccelByteUGCContentUtilitiesSortByV2::CREATED_TIME_DESC)</td></tr>
<tr class="memdesc:a77e73a112397ca7e936cb1fa0a67fcf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search contents specific to a channel.  <br /></td></tr>
<tr class="separator:a77e73a112397ca7e936cb1fa0a67fcf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefd109c2401f05ef150742bd1323043c" id="r_aefd109c2401f05ef150742bd1323043c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aefd109c2401f05ef150742bd1323043c">PublicSearchContentsSpecificToChannelV2</a> (FString const &amp;ChannelId, THandler&lt; <a class="el" href="structFAccelByteModelsUGCSearchContentsPagingResponseV2.html">FAccelByteModelsUGCSearchContentsPagingResponseV2</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError, int32 Limit=20, int32 Offset=0, EAccelByteUGCContentUtilitiesSortByV2 SortBy=EAccelByteUGCContentUtilitiesSortByV2::CREATED_TIME_DESC)</td></tr>
<tr class="memdesc:aefd109c2401f05ef150742bd1323043c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search contents specific to a channel. Can be used without logged in.  <br /></td></tr>
<tr class="separator:aefd109c2401f05ef150742bd1323043c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a175fcaf20c249740f82908c45a77aa25" id="r_a175fcaf20c249740f82908c45a77aa25"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a175fcaf20c249740f82908c45a77aa25">SearchContentsV2</a> (<a class="el" href="structFAccelByteModelsUGCFilterRequestV2.html">FAccelByteModelsUGCFilterRequestV2</a> const &amp;Filter, THandler&lt; <a class="el" href="structFAccelByteModelsUGCSearchContentsPagingResponseV2.html">FAccelByteModelsUGCSearchContentsPagingResponseV2</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError, int32 Limit=20, int32 Offset=0, EAccelByteUGCContentSortByV2 SortBy=EAccelByteUGCContentSortByV2::CREATED_TIME_DESC)</td></tr>
<tr class="memdesc:a175fcaf20c249740f82908c45a77aa25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all contents in current namespace.  <br /></td></tr>
<tr class="separator:a175fcaf20c249740f82908c45a77aa25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac126d3b3aaed93384385f9220e629e98" id="r_ac126d3b3aaed93384385f9220e629e98"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac126d3b3aaed93384385f9220e629e98">PublicSearchContentsV2</a> (<a class="el" href="structFAccelByteModelsUGCFilterRequestV2.html">FAccelByteModelsUGCFilterRequestV2</a> const &amp;Filter, THandler&lt; <a class="el" href="structFAccelByteModelsUGCSearchContentsPagingResponseV2.html">FAccelByteModelsUGCSearchContentsPagingResponseV2</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError, int32 Limit=20, int32 Offset=0, EAccelByteUGCContentSortByV2 SortBy=EAccelByteUGCContentSortByV2::CREATED_TIME_DESC)</td></tr>
<tr class="memdesc:ac126d3b3aaed93384385f9220e629e98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all contents in current namespace. Can be used without logged in.  <br /></td></tr>
<tr class="separator:ac126d3b3aaed93384385f9220e629e98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a156bbf3b9dc242366bb83a511da360fa" id="r_a156bbf3b9dc242366bb83a511da360fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a156bbf3b9dc242366bb83a511da360fa">GetContentBulkByIdsV2</a> (TArray&lt; FString &gt; const &amp;ContentIds, THandler&lt; TArray&lt; <a class="el" href="structFAccelByteModelsUGCContentResponseV2.html">FAccelByteModelsUGCContentResponseV2</a> &gt; &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a156bbf3b9dc242366bb83a511da360fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get contents by content Ids.  <br /></td></tr>
<tr class="separator:a156bbf3b9dc242366bb83a511da360fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7c656d74549380e47c50e6b96f01017" id="r_ad7c656d74549380e47c50e6b96f01017"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad7c656d74549380e47c50e6b96f01017">PublicGetContentBulkByIdsV2</a> (TArray&lt; FString &gt; const &amp;ContentIds, THandler&lt; TArray&lt; <a class="el" href="structFAccelByteModelsUGCContentResponseV2.html">FAccelByteModelsUGCContentResponseV2</a> &gt; &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:ad7c656d74549380e47c50e6b96f01017"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get contents by content Ids. Can be used without logged in.  <br /></td></tr>
<tr class="separator:ad7c656d74549380e47c50e6b96f01017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ccf7395bee49693af01c43d73016e44" id="r_a0ccf7395bee49693af01c43d73016e44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ccf7395bee49693af01c43d73016e44">GetContentByShareCodeV2</a> (FString const &amp;ShareCode, THandler&lt; <a class="el" href="structFAccelByteModelsUGCContentResponseV2.html">FAccelByteModelsUGCContentResponseV2</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a0ccf7395bee49693af01c43d73016e44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a content information by its share code.  <br /></td></tr>
<tr class="separator:a0ccf7395bee49693af01c43d73016e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadff241ffd9a9996af7ef3a019191573" id="r_aadff241ffd9a9996af7ef3a019191573"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aadff241ffd9a9996af7ef3a019191573">PublicGetContentByShareCodeV2</a> (FString const &amp;ShareCode, THandler&lt; <a class="el" href="structFAccelByteModelsUGCContentResponseV2.html">FAccelByteModelsUGCContentResponseV2</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:aadff241ffd9a9996af7ef3a019191573"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a content information by its share code. Can be used without logged in.  <br /></td></tr>
<tr class="separator:aadff241ffd9a9996af7ef3a019191573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9558ac491ae42dec6a247ffc4b7c4951" id="r_a9558ac491ae42dec6a247ffc4b7c4951"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9558ac491ae42dec6a247ffc4b7c4951">GetContentByContentIdV2</a> (FString const &amp;ContentId, THandler&lt; <a class="el" href="structFAccelByteModelsUGCContentResponseV2.html">FAccelByteModelsUGCContentResponseV2</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a9558ac491ae42dec6a247ffc4b7c4951"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a content information by its content id.  <br /></td></tr>
<tr class="separator:a9558ac491ae42dec6a247ffc4b7c4951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6f4c21e3cdcf457ead5b19980c6449f" id="r_ae6f4c21e3cdcf457ead5b19980c6449f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae6f4c21e3cdcf457ead5b19980c6449f">PublicGetContentByContentIdV2</a> (FString const &amp;ContentId, THandler&lt; <a class="el" href="structFAccelByteModelsUGCContentResponseV2.html">FAccelByteModelsUGCContentResponseV2</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:ae6f4c21e3cdcf457ead5b19980c6449f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a content information by its content id. Can be used without logged in.  <br /></td></tr>
<tr class="separator:ae6f4c21e3cdcf457ead5b19980c6449f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58c2d15c7bb5dac2b6196b189211da4a" id="r_a58c2d15c7bb5dac2b6196b189211da4a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a58c2d15c7bb5dac2b6196b189211da4a">CreateContentV2</a> (FString const &amp;ChannelId, <a class="el" href="structFAccelByteModelsCreateUGCRequestV2.html">FAccelByteModelsCreateUGCRequestV2</a> const &amp;CreateRequest, THandler&lt; <a class="el" href="structFAccelByteModelsUGCCreateUGCResponseV2.html">FAccelByteModelsUGCCreateUGCResponseV2</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a58c2d15c7bb5dac2b6196b189211da4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classAccelByte_1_1Api_1_1UGC.html" title="Provide APIs to access UGC service.">UGC</a> content with create content request.  <br /></td></tr>
<tr class="separator:a58c2d15c7bb5dac2b6196b189211da4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ac4bc317e2aefb2f8469c989511e301" id="r_a0ac4bc317e2aefb2f8469c989511e301"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ac4bc317e2aefb2f8469c989511e301">DeleteContentV2</a> (FString const &amp;ChannelId, FString const &amp;ContentId, FVoidHandler const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a0ac4bc317e2aefb2f8469c989511e301"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a content based on the its channel id and content id.  <br /></td></tr>
<tr class="separator:a0ac4bc317e2aefb2f8469c989511e301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59ced8b637d45f03c9f41d838a1d4d12" id="r_a59ced8b637d45f03c9f41d838a1d4d12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a59ced8b637d45f03c9f41d838a1d4d12">ModifyContentV2</a> (FString const &amp;ChannelId, FString const &amp;ContentId, <a class="el" href="structFAccelByteModelsModifyUGCRequestV2.html">FAccelByteModelsModifyUGCRequestV2</a> const &amp;ModifyRequest, THandler&lt; <a class="el" href="structFAccelByteModelsUGCModifyUGCResponseV2.html">FAccelByteModelsUGCModifyUGCResponseV2</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a59ced8b637d45f03c9f41d838a1d4d12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify existing content to update content metadata.  <br /></td></tr>
<tr class="separator:a59ced8b637d45f03c9f41d838a1d4d12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a201e625eebb3753bf94c26b12f7646fa" id="r_a201e625eebb3753bf94c26b12f7646fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a201e625eebb3753bf94c26b12f7646fa">GenerateUploadContentURLV2</a> (FString const &amp;ChannelId, FString const &amp;ContentId, <a class="el" href="structFAccelByteModelsUploadContentURLRequestV2.html">FAccelByteModelsUploadContentURLRequestV2</a> const &amp;UploadRequest, THandler&lt; <a class="el" href="structFAccelByteModelsUGCUploadContentURLResponseV2.html">FAccelByteModelsUGCUploadContentURLResponseV2</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a201e625eebb3753bf94c26b12f7646fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate Upload URL and Conten File Location.  <br /></td></tr>
<tr class="separator:a201e625eebb3753bf94c26b12f7646fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf104b28ffdc3460fa08a7662d678fe5" id="r_acf104b28ffdc3460fa08a7662d678fe5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf104b28ffdc3460fa08a7662d678fe5">UpdateContentFileLocationV2</a> (FString const &amp;ChannelId, FString const &amp;ContentId, FString const &amp;FileExtension, FString const &amp;S3Key, THandler&lt; <a class="el" href="structFAccelByteModelsUGCUpdateContentFileLocationResponseV2.html">FAccelByteModelsUGCUpdateContentFileLocationResponseV2</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:acf104b28ffdc3460fa08a7662d678fe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update Content File Location in S3.  <br /></td></tr>
<tr class="separator:acf104b28ffdc3460fa08a7662d678fe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33b9bfcd528d15adf43788d4407a43c0" id="r_a33b9bfcd528d15adf43788d4407a43c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a33b9bfcd528d15adf43788d4407a43c0">GetUserContentsV2</a> (FString const &amp;UserId, THandler&lt; <a class="el" href="structFAccelByteModelsUGCSearchContentsPagingResponseV2.html">FAccelByteModelsUGCSearchContentsPagingResponseV2</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError, int32 Limit=20, int32 Offset=0, EAccelByteUGCContentUtilitiesSortByV2 SortBy=EAccelByteUGCContentUtilitiesSortByV2::CREATED_TIME_DESC)</td></tr>
<tr class="memdesc:a33b9bfcd528d15adf43788d4407a43c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get user's generated contents.  <br /></td></tr>
<tr class="separator:a33b9bfcd528d15adf43788d4407a43c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5db3435857568c3b7b99db23dd5e7b56" id="r_a5db3435857568c3b7b99db23dd5e7b56"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5db3435857568c3b7b99db23dd5e7b56">PublicGetUserContentsV2</a> (FString const &amp;UserId, THandler&lt; <a class="el" href="structFAccelByteModelsUGCSearchContentsPagingResponseV2.html">FAccelByteModelsUGCSearchContentsPagingResponseV2</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError, int32 Limit=20, int32 Offset=0, EAccelByteUGCContentUtilitiesSortByV2 SortBy=EAccelByteUGCContentUtilitiesSortByV2::CREATED_TIME_DESC)</td></tr>
<tr class="memdesc:a5db3435857568c3b7b99db23dd5e7b56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get user's generated contents. Can be used without logged in.  <br /></td></tr>
<tr class="separator:a5db3435857568c3b7b99db23dd5e7b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5162becebdf137f77bb189d6f1618c40" id="r_a5162becebdf137f77bb189d6f1618c40"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5162becebdf137f77bb189d6f1618c40">UpdateContentScreenshotV2</a> (FString const &amp;ContentId, <a class="el" href="structFAccelByteModelsUGCUpdateScreenshotsV2.html">FAccelByteModelsUGCUpdateScreenshotsV2</a> const &amp;ScreenshotsRequest, THandler&lt; <a class="el" href="structFAccelByteModelsUGCUpdateScreenshotsV2.html">FAccelByteModelsUGCUpdateScreenshotsV2</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a5162becebdf137f77bb189d6f1618c40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update screenshots for content.  <br /></td></tr>
<tr class="separator:a5162becebdf137f77bb189d6f1618c40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4318fed2eeba415eeb027f247de7c44b" id="r_a4318fed2eeba415eeb027f247de7c44b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4318fed2eeba415eeb027f247de7c44b">UploadContentScreenshotV2</a> (FString const &amp;ContentId, <a class="el" href="structFAccelByteModelsUGCUploadScreenshotsRequestV2.html">FAccelByteModelsUGCUploadScreenshotsRequestV2</a> const &amp;ScreenshotsRequest, THandler&lt; <a class="el" href="structFAccelByteModelsUGCUpdateContentScreenshotResponse.html">FAccelByteModelsUGCUpdateContentScreenshotResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a4318fed2eeba415eeb027f247de7c44b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Upload screenshots for content.  <br /></td></tr>
<tr class="separator:a4318fed2eeba415eeb027f247de7c44b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87ba7bcdb63984dd219736a23a81df0c" id="r_a87ba7bcdb63984dd219736a23a81df0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a87ba7bcdb63984dd219736a23a81df0c">DeleteContentScreenshotV2</a> (FString const &amp;ContentId, FString const &amp;ScreenshotId, FVoidHandler const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a87ba7bcdb63984dd219736a23a81df0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete screenshots for content.  <br /></td></tr>
<tr class="separator:a87ba7bcdb63984dd219736a23a81df0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace8d10aa216243bd045a29e09a97d62d" id="r_ace8d10aa216243bd045a29e09a97d62d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace8d10aa216243bd045a29e09a97d62d">ModifyContentByShareCode</a> (FString const &amp;ChannelId, FString const &amp;ShareCode, <a class="el" href="structFAccelByteModelsUGCUpdateRequest.html">FAccelByteModelsUGCUpdateRequest</a> const &amp;ModifyRequest, THandler&lt; <a class="el" href="structFAccelByteModelsUGCResponse.html">FAccelByteModelsUGCResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:ace8d10aa216243bd045a29e09a97d62d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify existing content to update some information by share code.  <br /></td></tr>
<tr class="separator:ace8d10aa216243bd045a29e09a97d62d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29365c371ac4244701c3c7ce5426cfa4" id="r_a29365c371ac4244701c3c7ce5426cfa4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a29365c371ac4244701c3c7ce5426cfa4">ModifyContentShareCode</a> (FString const &amp;ChannelId, FString const &amp;ContentId, <a class="el" href="structFAccelByteModelsUGCModifyContentShareCodeRequest.html">FAccelByteModelsUGCModifyContentShareCodeRequest</a> const &amp;ModifyContentShareCodeRequest, THandler&lt; <a class="el" href="structFAccelByteModelsUGCResponse.html">FAccelByteModelsUGCResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a29365c371ac4244701c3c7ce5426cfa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the shareCode of a content.  <br /></td></tr>
<tr class="separator:a29365c371ac4244701c3c7ce5426cfa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51a89e54002e92d23dfcf32e3473ab99" id="r_a51a89e54002e92d23dfcf32e3473ab99"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a51a89e54002e92d23dfcf32e3473ab99">DeleteContentByShareCode</a> (FString const &amp;ChannelId, FString const &amp;ShareCode, FVoidHandler const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a51a89e54002e92d23dfcf32e3473ab99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a content based on the its channel id and share code.  <br /></td></tr>
<tr class="separator:a51a89e54002e92d23dfcf32e3473ab99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfece058e8721dcc2665629d2c766b83" id="r_abfece058e8721dcc2665629d2c766b83"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abfece058e8721dcc2665629d2c766b83">BulkGetContentByShareCodeV2</a> (const TArray&lt; FString &gt; &amp;ShareCodes, THandler&lt; TArray&lt; <a class="el" href="structFAccelByteModelsUGCContentResponseV2.html">FAccelByteModelsUGCContentResponseV2</a> &gt; &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:abfece058e8721dcc2665629d2c766b83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bulk Get contents by ShareCodes.  <br /></td></tr>
<tr class="separator:abfece058e8721dcc2665629d2c766b83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a38b7b8a1a4812d616fb562729709fc" id="r_a3a38b7b8a1a4812d616fb562729709fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3a38b7b8a1a4812d616fb562729709fc">ModifyContentShareCodeV2</a> (FString const &amp;ChannelId, FString const &amp;ContentId, <a class="el" href="structFAccelByteModelsUGCModifyContentShareCodeRequest.html">FAccelByteModelsUGCModifyContentShareCodeRequest</a> const &amp;ModifyContentShareCodeRequest, THandler&lt; <a class="el" href="structFAccelByteModelsUGCCreateUGCResponseV2.html">FAccelByteModelsUGCCreateUGCResponseV2</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a3a38b7b8a1a4812d616fb562729709fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the shareCode of a content.  <br /></td></tr>
<tr class="separator:a3a38b7b8a1a4812d616fb562729709fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4dd25db1931655a6f0452cfc1ceaa22" id="r_ad4dd25db1931655a6f0452cfc1ceaa22"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad4dd25db1931655a6f0452cfc1ceaa22">AddDownloadContentCountV2</a> (FString const &amp;ContentId, THandler&lt; <a class="el" href="structFAccelByteModelsUGCAddDownloadContentCountResponseV2.html">FAccelByteModelsUGCAddDownloadContentCountResponseV2</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:ad4dd25db1931655a6f0452cfc1ceaa22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add download count for a content.  <br /></td></tr>
<tr class="separator:ad4dd25db1931655a6f0452cfc1ceaa22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada345bfb37642d047ac7c76e65c47e92" id="r_ada345bfb37642d047ac7c76e65c47e92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada345bfb37642d047ac7c76e65c47e92">GetListContentDownloaderV2</a> (FString const &amp;ContentId, THandler&lt; <a class="el" href="structFAccelByteModelsUGCGetPaginatedContentDownloaderResponseV2.html">FAccelByteModelsUGCGetPaginatedContentDownloaderResponseV2</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError, FString const &amp;UserId=TEXT(&quot;&quot;), int32 Limit=20, int32 Offset=0, EAccelByteUGCContentUtilitiesSortByV2 SortBy=EAccelByteUGCContentUtilitiesSortByV2::CREATED_TIME_DESC)</td></tr>
<tr class="memdesc:ada345bfb37642d047ac7c76e65c47e92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get list of <a class="el" href="classAccelByte_1_1Api_1_1UGC.html" title="Provide APIs to access UGC service.">UGC</a> content downloader.  <br /></td></tr>
<tr class="separator:ada345bfb37642d047ac7c76e65c47e92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c99e903f14210e7d442757a5c720c3f" id="r_a0c99e903f14210e7d442757a5c720c3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c99e903f14210e7d442757a5c720c3f">GetListContentLikerV2</a> (FString const &amp;ContentId, THandler&lt; <a class="el" href="structFAccelByteModelsUGCGetPaginatedContentLikerResponseV2.html">FAccelByteModelsUGCGetPaginatedContentLikerResponseV2</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError, int32 Limit=20, int32 Offset=0, EAccelByteUGCContentUtilitiesSortByV2 SortBy=EAccelByteUGCContentUtilitiesSortByV2::CREATED_TIME_DESC)</td></tr>
<tr class="memdesc:a0c99e903f14210e7d442757a5c720c3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of users who like the content.  <br /></td></tr>
<tr class="separator:a0c99e903f14210e7d442757a5c720c3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbcd58a827b41be6a2fc7f4309b720c9" id="r_abbcd58a827b41be6a2fc7f4309b720c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abbcd58a827b41be6a2fc7f4309b720c9">UpdateLikeStatusToContentV2</a> (FString const &amp;ContentId, bool bLikeStatus, THandler&lt; <a class="el" href="structFAccelByteModelsUGCUpdateLikeStatusToContentResponse.html">FAccelByteModelsUGCUpdateLikeStatusToContentResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:abbcd58a827b41be6a2fc7f4309b720c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update like/unlike status to a content.  <br /></td></tr>
<tr class="separator:abbcd58a827b41be6a2fc7f4309b720c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8339ad0ceaf3983381081101cf54759" id="r_ab8339ad0ceaf3983381081101cf54759"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab8339ad0ceaf3983381081101cf54759">GetStagingContents</a> (EStagingContentRequestStatus Status, THandler&lt; <a class="el" href="structFAccelByteModelsUGCPaginatedListStagingContentResponse.html">FAccelByteModelsUGCPaginatedListStagingContentResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError, int32 Limit=20, int32 Offset=0, EAccelByteStagingContentUtilitiesSortBy SortBy=EAccelByteStagingContentUtilitiesSortBy::NONE)</td></tr>
<tr class="memdesc:ab8339ad0ceaf3983381081101cf54759"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a list of staging contents and sort by status.  <br /></td></tr>
<tr class="separator:ab8339ad0ceaf3983381081101cf54759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa303b2215dfe78872f82f9bf101847dc" id="r_aa303b2215dfe78872f82f9bf101847dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa303b2215dfe78872f82f9bf101847dc">GetStagingContentById</a> (FString const &amp;ContentId, THandler&lt; <a class="el" href="structFAccelByteModelsUGCStagingContentResponse.html">FAccelByteModelsUGCStagingContentResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:aa303b2215dfe78872f82f9bf101847dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get user staging content.  <br /></td></tr>
<tr class="separator:aa303b2215dfe78872f82f9bf101847dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61b36cb39b384dee2c19b79b358a6b28" id="r_a61b36cb39b384dee2c19b79b358a6b28"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a61b36cb39b384dee2c19b79b358a6b28">UpdateStagingContent</a> (FString const &amp;ContentId, <a class="el" href="structFAccelByteModelsUGCUpdateContentFileLocationRequestV2.html">FAccelByteModelsUGCUpdateContentFileLocationRequestV2</a> UpdateRequest, THandler&lt; <a class="el" href="structFAccelByteModelsUGCStagingContentResponse.html">FAccelByteModelsUGCStagingContentResponse</a> &gt; const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:a61b36cb39b384dee2c19b79b358a6b28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update staging content by content id using update request struct.  <br /></td></tr>
<tr class="separator:a61b36cb39b384dee2c19b79b358a6b28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada95fb3f83b72010ea96ad95e8a86d86" id="r_ada95fb3f83b72010ea96ad95e8a86d86"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada95fb3f83b72010ea96ad95e8a86d86">DeleteStagingContent</a> (FString const &amp;ContentId, FVoidHandler const &amp;OnSuccess, FErrorHandler const &amp;OnError)</td></tr>
<tr class="memdesc:ada95fb3f83b72010ea96ad95e8a86d86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete staging content by user id and content id.  <br /></td></tr>
<tr class="separator:ada95fb3f83b72010ea96ad95e8a86d86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classAccelByte_1_1FApiBase"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_classAccelByte_1_1FApiBase')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classAccelByte_1_1FApiBase.html">AccelByte::FApiBase</a></td></tr>
<tr class="memitem:ac408a88edb62afa5bb1cbfe388fb7ada inherit pub_methods_classAccelByte_1_1FApiBase" id="r_ac408a88edb62afa5bb1cbfe388fb7ada"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>FApiBase</b> (<a class="el" href="classAccelByte_1_1Credentials.html">Credentials</a> const &amp;InCredentialsRef, <a class="el" href="classAccelByte_1_1Settings.html">Settings</a> const &amp;InSettingsRef, <a class="el" href="classAccelByte_1_1FHttpRetryScheduler.html">FHttpRetryScheduler</a> &amp;InHttpRef)</td></tr>
<tr class="separator:ac408a88edb62afa5bb1cbfe388fb7ada inherit pub_methods_classAccelByte_1_1FApiBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classAccelByte_1_1FApiBase"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_methods_classAccelByte_1_1FApiBase')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classAccelByte_1_1FApiBase.html">AccelByte::FApiBase</a></td></tr>
<tr class="memitem:abf73c69f11a74c5d79ed767d7e9de861 inherit pro_methods_classAccelByte_1_1FApiBase" id="r_abf73c69f11a74c5d79ed767d7e9de861"><td class="memTemplParams" colspan="2">
template&lt;typename T &gt; </td></tr>
<tr class="memitem:abf73c69f11a74c5d79ed767d7e9de861 inherit pro_methods_classAccelByte_1_1FApiBase"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ValidateAccelByteId</b> (FString const &amp;Id, EAccelByteIdHypensRule HypenRule, FString const &amp;ErrorMessage, T const &amp;OnError)</td></tr>
<tr class="separator:abf73c69f11a74c5d79ed767d7e9de861 inherit pro_methods_classAccelByte_1_1FApiBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classAccelByte_1_1FApiBase"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_attribs_classAccelByte_1_1FApiBase')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classAccelByte_1_1FApiBase.html">AccelByte::FApiBase</a></td></tr>
<tr class="memitem:a585cbf945993a436bb4447c8d6635be5 inherit pro_attribs_classAccelByte_1_1FApiBase" id="r_a585cbf945993a436bb4447c8d6635be5"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classAccelByte_1_1Credentials.html">Credentials</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>CredentialsRef</b></td></tr>
<tr class="separator:a585cbf945993a436bb4447c8d6635be5 inherit pro_attribs_classAccelByte_1_1FApiBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8ffc36382a4204edb20a6d3430c13ad inherit pro_attribs_classAccelByte_1_1FApiBase" id="r_ae8ffc36382a4204edb20a6d3430c13ad"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classAccelByte_1_1Settings.html">Settings</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>SettingsRef</b></td></tr>
<tr class="separator:ae8ffc36382a4204edb20a6d3430c13ad inherit pro_attribs_classAccelByte_1_1FApiBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be9ff9374ca90ae6cb787c74837d85f inherit pro_attribs_classAccelByte_1_1FApiBase" id="r_a8be9ff9374ca90ae6cb787c74837d85f"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classAccelByte_1_1FHttpRetryScheduler.html">FHttpRetryScheduler</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>HttpRef</b></td></tr>
<tr class="separator:a8be9ff9374ca90ae6cb787c74837d85f inherit pro_attribs_classAccelByte_1_1FApiBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd2ef10eecc71f4d34515276ab6a8fcb inherit pro_attribs_classAccelByte_1_1FApiBase" id="r_afd2ef10eecc71f4d34515276ab6a8fcb"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classAccelByte_1_1FHttpClient.html">FHttpClient</a>&#160;</td><td class="memItemRight" valign="bottom"><b>HttpClient</b></td></tr>
<tr class="separator:afd2ef10eecc71f4d34515276ab6a8fcb inherit pro_attribs_classAccelByte_1_1FApiBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Provide APIs to access <a class="el" href="classAccelByte_1_1Api_1_1UGC.html" title="Provide APIs to access UGC service.">UGC</a> service. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ad4dd25db1931655a6f0452cfc1ceaa22" name="ad4dd25db1931655a6f0452cfc1ceaa22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4dd25db1931655a6f0452cfc1ceaa22">&#9670;&#160;</a></span>AddDownloadContentCountV2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::UGC::AddDownloadContentCountV2 </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ContentId</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="structFAccelByteModelsUGCAddDownloadContentCountResponseV2.html">FAccelByteModelsUGCAddDownloadContentCountResponseV2</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add download count for a content. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ContentId</td><td>The id of the content. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is <a class="el" href="structFAccelByteModelsUGCAddDownloadContentCountResponseV2.html">FAccelByteModelsUGCAddDownloadContentCountResponseV2</a>. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac1204f672cfcfdca674de9b44b5a0d68" name="ac1204f672cfcfdca674de9b44b5a0d68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1204f672cfcfdca674de9b44b5a0d68">&#9670;&#160;</a></span>BulkGetContentByShareCode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::UGC::BulkGetContentByShareCode </td>
          <td>(</td>
          <td class="paramtype">const TArray&lt; FString &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ShareCodes</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; TArray&lt; <a class="el" href="structFAccelByteModelsUGCContentResponse.html">FAccelByteModelsUGCContentResponse</a> &gt; &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bulk Get contents by ShareCodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ShareCodes</td><td>Content ShareCodes Array <br  />
 </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abfece058e8721dcc2665629d2c766b83" name="abfece058e8721dcc2665629d2c766b83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfece058e8721dcc2665629d2c766b83">&#9670;&#160;</a></span>BulkGetContentByShareCodeV2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::UGC::BulkGetContentByShareCodeV2 </td>
          <td>(</td>
          <td class="paramtype">const TArray&lt; FString &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ShareCodes</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; TArray&lt; <a class="el" href="structFAccelByteModelsUGCContentResponseV2.html">FAccelByteModelsUGCContentResponseV2</a> &gt; &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bulk Get contents by ShareCodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ShareCodes</td><td>Content ShareCodes Array <br  />
 </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a122877c1a060ed3389d75e554e5e79" name="a4a122877c1a060ed3389d75e554e5e79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a122877c1a060ed3389d75e554e5e79">&#9670;&#160;</a></span>CreateChannel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::UGC::CreateChannel </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ChannelName</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="structFAccelByteModelsUGCChannelResponse.html">FAccelByteModelsUGCChannelResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a player's channel with specific channel name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ChannelName</td><td>The name of the channel. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is <a class="el" href="structFAccelByteModelsUGCChannelResponse.html">FAccelByteModelsUGCChannelResponse</a>. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adc43f7665279b314fd26989290b38dd2" name="adc43f7665279b314fd26989290b38dd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc43f7665279b314fd26989290b38dd2">&#9670;&#160;</a></span>CreateContent() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::UGC::CreateContent </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ChannelId</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structFAccelByteModelsUGCRequest.html">FAccelByteModelsUGCRequest</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>UGCRequest</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="structFAccelByteModelsUGCResponse.html">FAccelByteModelsUGCResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a content with FString preview and get the payload url to upload the content. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ChannelId</td><td>The id of the content's channel. </td></tr>
    <tr><td class="paramname">UGCRequest</td><td>Detail information for the content request. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is <a class="el" href="structFAccelByteModelsUGCResponse.html">FAccelByteModelsUGCResponse</a>. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f9c5eacc22ac41dac341e54d407e06e" name="a8f9c5eacc22ac41dac341e54d407e06e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f9c5eacc22ac41dac341e54d407e06e">&#9670;&#160;</a></span>CreateContent() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::UGC::CreateContent </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ChannelId</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>Name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>Type</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>SubType</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TArray&lt; FString &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>Tags</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TArray&lt; uint8 &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>Preview</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>FileExtension</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="structFAccelByteModelsUGCResponse.html">FAccelByteModelsUGCResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString</td>          <td class="paramname"><span class="paramname"><em>ContentType</em><span class="paramdefsep"> = </span><span class="paramdefval">TEXT(&quot;application/octet-stream&quot;)</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a content with TArray&lt;uint8&gt; Preview parameter and get the payload url to upload the content. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ChannelId</td><td>The id of the content's channel. </td></tr>
    <tr><td class="paramname">Name</td><td>Name of the content. </td></tr>
    <tr><td class="paramname">Type</td><td>Type of the content. </td></tr>
    <tr><td class="paramname">SubType</td><td>SubType of the content. </td></tr>
    <tr><td class="paramname">Tags</td><td>Tags of the content. </td></tr>
    <tr><td class="paramname">Preview</td><td>The TArray&lt;uint8&gt; of the content's Preview </td></tr>
    <tr><td class="paramname">FileExtension</td><td>FileExtension of the content. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is <a class="el" href="structFAccelByteModelsUGCResponse.html">FAccelByteModelsUGCResponse</a>. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
    <tr><td class="paramname">ContentType</td><td>The specific type of the content's created, default value is "application/octet-stream". </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a58c2d15c7bb5dac2b6196b189211da4a" name="a58c2d15c7bb5dac2b6196b189211da4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58c2d15c7bb5dac2b6196b189211da4a">&#9670;&#160;</a></span>CreateContentV2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::UGC::CreateContentV2 </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ChannelId</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structFAccelByteModelsCreateUGCRequestV2.html">FAccelByteModelsCreateUGCRequestV2</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>CreateRequest</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="structFAccelByteModelsUGCCreateUGCResponseV2.html">FAccelByteModelsUGCCreateUGCResponseV2</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <a class="el" href="classAccelByte_1_1Api_1_1UGC.html" title="Provide APIs to access UGC service.">UGC</a> content with create content request. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ChannelId</td><td>The id of the content's channel. </td></tr>
    <tr><td class="paramname">CreateRequest</td><td>Detail information for the content request. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is <a class="el" href="structFAccelByteModelsUGCCreateUGCResponseV2.html">FAccelByteModelsUGCCreateUGCResponseV2</a>. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a80d1b20440cc4ec12d1bbffbf96b5140" name="a80d1b20440cc4ec12d1bbffbf96b5140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80d1b20440cc4ec12d1bbffbf96b5140">&#9670;&#160;</a></span>DeleteChannel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::UGC::DeleteChannel </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ChannelId</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FVoidHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a player's channel based on the its channel id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ChannelId</td><td>The id of the channel that will be deleted. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0f0acae6dfbe5c05eadff9135b8fb02e" name="a0f0acae6dfbe5c05eadff9135b8fb02e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f0acae6dfbe5c05eadff9135b8fb02e">&#9670;&#160;</a></span>DeleteContent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::UGC::DeleteContent </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ChannelId</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ContentId</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FVoidHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a content based on the its channel id and content id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ChannelId</td><td>The id of the content's channel. </td></tr>
    <tr><td class="paramname">ContentId</td><td>The id of the content that will be deleted. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a51a89e54002e92d23dfcf32e3473ab99" name="a51a89e54002e92d23dfcf32e3473ab99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51a89e54002e92d23dfcf32e3473ab99">&#9670;&#160;</a></span>DeleteContentByShareCode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::UGC::DeleteContentByShareCode </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ChannelId</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ShareCode</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FVoidHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a content based on the its channel id and share code. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ChannelId</td><td>The id of the content's channel. </td></tr>
    <tr><td class="paramname">ShareCode</td><td>The share code of the content that will be fetched. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a87ba7bcdb63984dd219736a23a81df0c" name="a87ba7bcdb63984dd219736a23a81df0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87ba7bcdb63984dd219736a23a81df0c">&#9670;&#160;</a></span>DeleteContentScreenshotV2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::UGC::DeleteContentScreenshotV2 </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ContentId</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ScreenshotId</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FVoidHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete screenshots for content. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ContentId</td><td>Content Id. </td></tr>
    <tr><td class="paramname">ScreenshotId</td><td>Screenshot Id </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0ac4bc317e2aefb2f8469c989511e301" name="a0ac4bc317e2aefb2f8469c989511e301"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ac4bc317e2aefb2f8469c989511e301">&#9670;&#160;</a></span>DeleteContentV2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::UGC::DeleteContentV2 </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ChannelId</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ContentId</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FVoidHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a content based on the its channel id and content id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ChannelId</td><td>The id of the content's channel. </td></tr>
    <tr><td class="paramname">ContentId</td><td>The id of the content that will be deleted. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada95fb3f83b72010ea96ad95e8a86d86" name="ada95fb3f83b72010ea96ad95e8a86d86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada95fb3f83b72010ea96ad95e8a86d86">&#9670;&#160;</a></span>DeleteStagingContent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::UGC::DeleteStagingContent </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ContentId</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FVoidHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete staging content by user id and content id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ContentId</td><td>Target content id to update the content </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a201e625eebb3753bf94c26b12f7646fa" name="a201e625eebb3753bf94c26b12f7646fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a201e625eebb3753bf94c26b12f7646fa">&#9670;&#160;</a></span>GenerateUploadContentURLV2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::UGC::GenerateUploadContentURLV2 </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ChannelId</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ContentId</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structFAccelByteModelsUploadContentURLRequestV2.html">FAccelByteModelsUploadContentURLRequestV2</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>UploadRequest</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="structFAccelByteModelsUGCUploadContentURLResponseV2.html">FAccelByteModelsUGCUploadContentURLResponseV2</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate Upload URL and Conten File Location. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ChannelId</td><td>The id of the content's channel. </td></tr>
    <tr><td class="paramname">ContentId</td><td>The id of the content. </td></tr>
    <tr><td class="paramname">UploadRequest</td><td>Detail information for the upload request. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is <a class="el" href="structFAccelByteModelsUGCUploadContentURLResponseV2.html">FAccelByteModelsUGCUploadContentURLResponseV2</a>. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af3cd61400775c3c1f946d7282a197efa" name="af3cd61400775c3c1f946d7282a197efa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3cd61400775c3c1f946d7282a197efa">&#9670;&#160;</a></span>GetChannels() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::UGC::GetChannels </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>UserId</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="structFAccelByteModelsUGCChannelsPagingResponse.html">FAccelByteModelsUGCChannelsPagingResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Limit</em><span class="paramdefsep"> = </span><span class="paramdefval">1000</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Offset</em><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ChannelName</em><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all of the player's channels. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">UserId</td><td><a class="el" href="classAccelByte_1_1Api_1_1User.html" title="User management API for creating user, verifying user, and resetting password.">User</a> Id </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is <a class="el" href="structFAccelByteModelsUGCChannelsPagingResponse.html">FAccelByteModelsUGCChannelsPagingResponse</a>. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
    <tr><td class="paramname">Limit</td><td>The limit of the channel results. Default value is 1000. </td></tr>
    <tr><td class="paramname">Offset</td><td>The offset of the channel results. Default value is 0. </td></tr>
    <tr><td class="paramname">ChannelName</td><td>The name of the channel you want to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a79d576353f7c74513e5f09fb263416da" name="a79d576353f7c74513e5f09fb263416da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79d576353f7c74513e5f09fb263416da">&#9670;&#160;</a></span>GetChannels() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::UGC::GetChannels </td>
          <td>(</td>
          <td class="paramtype">THandler&lt; <a class="el" href="structFAccelByteModelsUGCChannelsPagingResponse.html">FAccelByteModelsUGCChannelsPagingResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Limit</em><span class="paramdefsep"> = </span><span class="paramdefval">1000</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Offset</em><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ChannelName</em><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all of the player's channels. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is <a class="el" href="structFAccelByteModelsUGCChannelsPagingResponse.html">FAccelByteModelsUGCChannelsPagingResponse</a>. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
    <tr><td class="paramname">Limit</td><td>The limit of the channel results. Default value is 1000. </td></tr>
    <tr><td class="paramname">Offset</td><td>The offset of the channel results. Default value is 0. </td></tr>
    <tr><td class="paramname">ChannelName</td><td>The name of the channel you want to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5f4332ffb4f9852bc753444ec0c02b36" name="a5f4332ffb4f9852bc753444ec0c02b36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f4332ffb4f9852bc753444ec0c02b36">&#9670;&#160;</a></span>GetContentBulk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::UGC::GetContentBulk </td>
          <td>(</td>
          <td class="paramtype">const TArray&lt; FString &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ContentIds</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; TArray&lt; <a class="el" href="structFAccelByteModelsUGCContentResponse.html">FAccelByteModelsUGCContentResponse</a> &gt; &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get contents by content Ids. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ContentIds</td><td>Content Ids Array <br  />
 </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a156bbf3b9dc242366bb83a511da360fa" name="a156bbf3b9dc242366bb83a511da360fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a156bbf3b9dc242366bb83a511da360fa">&#9670;&#160;</a></span>GetContentBulkByIdsV2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::UGC::GetContentBulkByIdsV2 </td>
          <td>(</td>
          <td class="paramtype">TArray&lt; FString &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>ContentIds</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; TArray&lt; <a class="el" href="structFAccelByteModelsUGCContentResponseV2.html">FAccelByteModelsUGCContentResponseV2</a> &gt; &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get contents by content Ids. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ContentIds</td><td>Content Ids Array </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is TArray&lt;FAccelByteModelsUGCContentResponseV2&gt;. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a60e8e41dac74635a6daa89904745928c" name="a60e8e41dac74635a6daa89904745928c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60e8e41dac74635a6daa89904745928c">&#9670;&#160;</a></span>GetContentByContentId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::UGC::GetContentByContentId </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ContentId</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="structFAccelByteModelsUGCContentResponse.html">FAccelByteModelsUGCContentResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a content information by its content id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ContentId</td><td>The id of the content that will be fetched. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is <a class="el" href="structFAccelByteModelsUGCContentResponse.html">FAccelByteModelsUGCContentResponse</a>. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9558ac491ae42dec6a247ffc4b7c4951" name="a9558ac491ae42dec6a247ffc4b7c4951"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9558ac491ae42dec6a247ffc4b7c4951">&#9670;&#160;</a></span>GetContentByContentIdV2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::UGC::GetContentByContentIdV2 </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ContentId</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="structFAccelByteModelsUGCContentResponseV2.html">FAccelByteModelsUGCContentResponseV2</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a content information by its content id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ContentId</td><td>The id of the content that will be fetched. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is <a class="el" href="structFAccelByteModelsUGCContentResponseV2.html">FAccelByteModelsUGCContentResponseV2</a>. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a631fd51106a81ea412a9f73a11c62250" name="a631fd51106a81ea412a9f73a11c62250"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a631fd51106a81ea412a9f73a11c62250">&#9670;&#160;</a></span>GetContentByShareCode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::UGC::GetContentByShareCode </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ShareCode</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="structFAccelByteModelsUGCContentResponse.html">FAccelByteModelsUGCContentResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a content information by its share code. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ShareCode</td><td>The share code of the content that will be fetched. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is <a class="el" href="structFAccelByteModelsUGCContentResponse.html">FAccelByteModelsUGCContentResponse</a>. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0ccf7395bee49693af01c43d73016e44" name="a0ccf7395bee49693af01c43d73016e44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ccf7395bee49693af01c43d73016e44">&#9670;&#160;</a></span>GetContentByShareCodeV2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::UGC::GetContentByShareCodeV2 </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ShareCode</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="structFAccelByteModelsUGCContentResponseV2.html">FAccelByteModelsUGCContentResponseV2</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a content information by its share code. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ShareCode</td><td>The share code of the content that will be fetched. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is <a class="el" href="structFAccelByteModelsUGCContentResponseV2.html">FAccelByteModelsUGCContentResponseV2</a>. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac94a8448a3c8fd897e6512c961ee6ba1" name="ac94a8448a3c8fd897e6512c961ee6ba1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac94a8448a3c8fd897e6512c961ee6ba1">&#9670;&#160;</a></span>GetContentPreview() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::UGC::GetContentPreview </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ContentId</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="structFAccelByteModelsUGCPreview.html">FAccelByteModelsUGCPreview</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get content Preview as <a class="el" href="structFAccelByteModelsUGCPreview.html">FAccelByteModelsUGCPreview</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ContentId</td><td>The id of the Preview's content that will be fetched. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is <a class="el" href="structFAccelByteModelsUGCPreview.html">FAccelByteModelsUGCPreview</a>. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a252c44da0b3a0d54aef9c9f666c7ac3e" name="a252c44da0b3a0d54aef9c9f666c7ac3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a252c44da0b3a0d54aef9c9f666c7ac3e">&#9670;&#160;</a></span>GetContentPreview() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::UGC::GetContentPreview </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ContentId</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; TArray&lt; uint8 &gt; &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get content preview as TArray&lt;uint8&gt;. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ContentId</td><td>The id of the Preview's content that will be fetched. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is TArray&lt;uint8&gt;. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5de01684b1b296cfedf9f9ca8cdcf418" name="a5de01684b1b296cfedf9f9ca8cdcf418"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5de01684b1b296cfedf9f9ca8cdcf418">&#9670;&#160;</a></span>GetCreator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::UGC::GetCreator </td>
          <td>(</td>
          <td class="paramtype">const FString &amp;</td>          <td class="paramname"><span class="paramname"><em>UserId</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="structFAccelByteModelsUGCGetListFollowersResponse.html">FAccelByteModelsUGCGetListFollowersResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get creator stats: number of total like by other user, number of total following and follower user. <br  />
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">UserId</td><td><a class="el" href="classAccelByte_1_1Api_1_1User.html" title="User management API for creating user, verifying user, and resetting password.">User</a> Id </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa3730c7c330d38fa439988e358ffdaec" name="aa3730c7c330d38fa439988e358ffdaec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3730c7c330d38fa439988e358ffdaec">&#9670;&#160;</a></span>GetFollowedContent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::UGC::GetFollowedContent </td>
          <td>(</td>
          <td class="paramtype">THandler&lt; <a class="el" href="structFAccelByteModelsUGCContentPageResponse.html">FAccelByteModelsUGCContentPageResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Limit</em><span class="paramdefsep"> = </span><span class="paramdefval">1000</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Offset</em><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get contents from followed creators. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
    <tr><td class="paramname">Limit</td><td>Number of content per page. Default value : 1000 </td></tr>
    <tr><td class="paramname">Offset</td><td>The offset number to retrieve. Default value : 0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0686e5f56eeda4aa075443e78a6cf963" name="a0686e5f56eeda4aa075443e78a6cf963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0686e5f56eeda4aa075443e78a6cf963">&#9670;&#160;</a></span>GetFollowedUsers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::UGC::GetFollowedUsers </td>
          <td>(</td>
          <td class="paramtype">THandler&lt; <a class="el" href="structFAccelByteModelsUGCFollowedUsersResponse.html">FAccelByteModelsUGCFollowedUsersResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Limit</em><span class="paramdefsep"> = </span><span class="paramdefval">1000</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Offset</em><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get followed creators. <br  />
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
    <tr><td class="paramname">Limit</td><td>Number of content per page. Default value : 1000 </td></tr>
    <tr><td class="paramname">Offset</td><td>The offset number to retrieve. Default value : 0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa944239e28ca2b65baeeb00713626e74" name="aa944239e28ca2b65baeeb00713626e74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa944239e28ca2b65baeeb00713626e74">&#9670;&#160;</a></span>GetGroups()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::UGC::GetGroups </td>
          <td>(</td>
          <td class="paramtype">const FString &amp;</td>          <td class="paramname"><span class="paramname"><em>UserId</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="structFAccelByteModelsUGCGetGroupsResponse.html">FAccelByteModelsUGCGetGroupsResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Limit</em><span class="paramdefsep"> = </span><span class="paramdefval">1000</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Offset</em><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all user groups. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">UserId</td><td><a class="el" href="classAccelByte_1_1Api_1_1User.html" title="User management API for creating user, verifying user, and resetting password.">User</a> Id </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
    <tr><td class="paramname">Limit</td><td>Number of content per page. Default value : 1000 </td></tr>
    <tr><td class="paramname">Offset</td><td>The offset number to retrieve. Default value : 0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af19c1605d7005e8f268afa3b212eb55f" name="af19c1605d7005e8f268afa3b212eb55f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af19c1605d7005e8f268afa3b212eb55f">&#9670;&#160;</a></span>GetLikedContent() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::UGC::GetLikedContent </td>
          <td>(</td>
          <td class="paramtype">const TArray&lt; FString &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Tags</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FString &amp;</td>          <td class="paramname"><span class="paramname"><em>Name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FString &amp;</td>          <td class="paramname"><span class="paramname"><em>Type</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FString &amp;</td>          <td class="paramname"><span class="paramname"><em>Subtype</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>IsOfficial</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="structFAccelByteModelsUGCContentPageResponse.html">FAccelByteModelsUGCContentPageResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Limit</em><span class="paramdefsep"> = </span><span class="paramdefval">1000</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Offset</em><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EAccelByteLikedContentSortBy</td>          <td class="paramname"><span class="paramname"><em>SortBy</em><span class="paramdefsep"> = </span><span class="paramdefval">EAccelByteLikedContentSortBy::DATE</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EAccelByteUgcOrderBy</td>          <td class="paramname"><span class="paramname"><em>OrderBy</em><span class="paramdefsep"> = </span><span class="paramdefval">EAccelByteUgcOrderBy::DESC</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get liked contents. <br  />
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Tags</td><td>Content Tags. </td></tr>
    <tr><td class="paramname">Name</td><td>Content Name. </td></tr>
    <tr><td class="paramname">Type</td><td>Content Type. </td></tr>
    <tr><td class="paramname">Subtype</td><td>Content Subtype. </td></tr>
    <tr><td class="paramname">IsOfficial</td><td>Filter only official contents </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
    <tr><td class="paramname">Limit</td><td>Number of content per page. Default value : 1000 </td></tr>
    <tr><td class="paramname">Offset</td><td>The offset number to retrieve. Default value : 0 </td></tr>
    <tr><td class="paramname">SortBy</td><td>Sorting criteria, name,download,like,date. default=date. </td></tr>
    <tr><td class="paramname">OrderBy</td><td>Sorting order: asc, desc. default=desc <br  />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a68d8b0dfe63fff3b5e66a031cbb6c1d2" name="a68d8b0dfe63fff3b5e66a031cbb6c1d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68d8b0dfe63fff3b5e66a031cbb6c1d2">&#9670;&#160;</a></span>GetLikedContent() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::UGC::GetLikedContent </td>
          <td>(</td>
          <td class="paramtype">const TArray&lt; FString &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Tags</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FString &amp;</td>          <td class="paramname"><span class="paramname"><em>Name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FString &amp;</td>          <td class="paramname"><span class="paramname"><em>Type</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FString &amp;</td>          <td class="paramname"><span class="paramname"><em>Subtype</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>IsOfficial</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="structFAccelByteModelsUGCContentPageResponse.html">FAccelByteModelsUGCContentPageResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Limit</em><span class="paramdefsep"> = </span><span class="paramdefval">1000</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Offset</em><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EAccelByteUgcSortBy</td>          <td class="paramname"><span class="paramname"><em>SortBy</em><span class="paramdefsep"> = </span><span class="paramdefval">EAccelByteUgcSortBy::DATE</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EAccelByteUgcOrderBy</td>          <td class="paramname"><span class="paramname"><em>OrderBy</em><span class="paramdefsep"> = </span><span class="paramdefval">EAccelByteUgcOrderBy::DESC</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get liked contents. <br  />
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Tags</td><td>Content Tags. </td></tr>
    <tr><td class="paramname">Name</td><td>Content Name. </td></tr>
    <tr><td class="paramname">Type</td><td>Content Type. </td></tr>
    <tr><td class="paramname">Subtype</td><td>Content Subtype. </td></tr>
    <tr><td class="paramname">IsOfficial</td><td>Filter only official contents </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
    <tr><td class="paramname">Limit</td><td>Number of content per page. Default value : 1000 </td></tr>
    <tr><td class="paramname">Offset</td><td>The offset number to retrieve. Default value : 0 </td></tr>
    <tr><td class="paramname">SortBy</td><td>Sorting criteria, name,download,like,date. default=date. </td></tr>
    <tr><td class="paramname">OrderBy</td><td>Sorting order: asc, desc. default=desc <br  />
</td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000005">Deprecated</a></b></dt><dd>This method will be removed in the future, so please use void GetLikedContent(const TArray&lt;FString&gt;&amp; Tags , ... , EAccelByteLikedContentSortBy SortBy = EAccelByteLikedContentSortBy::DATE , EAccelByteUgcOrderBy OrderBy = EAccelByteUgcOrderBy::DESC); </dd></dl>

</div>
</div>
<a id="ada345bfb37642d047ac7c76e65c47e92" name="ada345bfb37642d047ac7c76e65c47e92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada345bfb37642d047ac7c76e65c47e92">&#9670;&#160;</a></span>GetListContentDownloaderV2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::UGC::GetListContentDownloaderV2 </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ContentId</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="structFAccelByteModelsUGCGetPaginatedContentDownloaderResponseV2.html">FAccelByteModelsUGCGetPaginatedContentDownloaderResponseV2</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>UserId</em><span class="paramdefsep"> = </span><span class="paramdefval">TEXT(&quot;&quot;)</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Limit</em><span class="paramdefsep"> = </span><span class="paramdefval">20</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Offset</em><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EAccelByteUGCContentUtilitiesSortByV2</td>          <td class="paramname"><span class="paramname"><em>SortBy</em><span class="paramdefsep"> = </span><span class="paramdefval">EAccelByteUGCContentUtilitiesSortByV2::CREATED_TIME_DESC</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get list of <a class="el" href="classAccelByte_1_1Api_1_1UGC.html" title="Provide APIs to access UGC service.">UGC</a> content downloader. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ContentId</td><td>The id of the content. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is <a class="el" href="structFAccelByteModelsUGCGetPaginatedContentDownloaderResponseV2.html">FAccelByteModelsUGCGetPaginatedContentDownloaderResponseV2</a>. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
    <tr><td class="paramname">UserId</td><td>The id of the user who downloaded the content. </td></tr>
    <tr><td class="paramname">Limit</td><td>Number of content per page. Default value : 1000 </td></tr>
    <tr><td class="paramname">Offset</td><td>The offset number to retrieve. Default value : 0 </td></tr>
    <tr><td class="paramname">SortBy</td><td>Sorting criteria: created time with asc or desc. default = created time and desc. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0c99e903f14210e7d442757a5c720c3f" name="a0c99e903f14210e7d442757a5c720c3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c99e903f14210e7d442757a5c720c3f">&#9670;&#160;</a></span>GetListContentLikerV2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::UGC::GetListContentLikerV2 </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ContentId</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="structFAccelByteModelsUGCGetPaginatedContentLikerResponseV2.html">FAccelByteModelsUGCGetPaginatedContentLikerResponseV2</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Limit</em><span class="paramdefsep"> = </span><span class="paramdefval">20</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Offset</em><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EAccelByteUGCContentUtilitiesSortByV2</td>          <td class="paramname"><span class="paramname"><em>SortBy</em><span class="paramdefsep"> = </span><span class="paramdefval">EAccelByteUGCContentUtilitiesSortByV2::CREATED_TIME_DESC</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a list of users who like the content. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ContentId</td><td>The id of the content. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is <a class="el" href="structFAccelByteModelsUGCGetPaginatedContentLikerResponseV2.html">FAccelByteModelsUGCGetPaginatedContentLikerResponseV2</a>. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
    <tr><td class="paramname">Limit</td><td>Number of content per page. Default value : 1000 </td></tr>
    <tr><td class="paramname">Offset</td><td>The offset number to retrieve. Default value : 0 </td></tr>
    <tr><td class="paramname">SortBy</td><td>Sorting criteria: created time with asc or desc. default = created time and desc. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac52e981ec4d1dc2b65cafb17a30d8388" name="ac52e981ec4d1dc2b65cafb17a30d8388"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac52e981ec4d1dc2b65cafb17a30d8388">&#9670;&#160;</a></span>GetListFollowers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::UGC::GetListFollowers </td>
          <td>(</td>
          <td class="paramtype">const FString &amp;</td>          <td class="paramname"><span class="paramname"><em>UserId</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="structFAccelByteModelsUGCGetListFollowersPagingResponse.html">FAccelByteModelsUGCGetListFollowersPagingResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Limit</em><span class="paramdefsep"> = </span><span class="paramdefval">1000</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Offset</em><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get list of followers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">UserId</td><td>The id of the user that will be given it's followers. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
    <tr><td class="paramname">Limit</td><td>Number of user per page, Default value : 1000. </td></tr>
    <tr><td class="paramname">Offset</td><td>The offset number to retrieve, Default value : 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa303b2215dfe78872f82f9bf101847dc" name="aa303b2215dfe78872f82f9bf101847dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa303b2215dfe78872f82f9bf101847dc">&#9670;&#160;</a></span>GetStagingContentById()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::UGC::GetStagingContentById </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ContentId</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="structFAccelByteModelsUGCStagingContentResponse.html">FAccelByteModelsUGCStagingContentResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get user staging content. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ContentId</td><td>Target content id to retrieved </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is FAccelByteModelsStagingContentResponse. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab8339ad0ceaf3983381081101cf54759" name="ab8339ad0ceaf3983381081101cf54759"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8339ad0ceaf3983381081101cf54759">&#9670;&#160;</a></span>GetStagingContents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::UGC::GetStagingContents </td>
          <td>(</td>
          <td class="paramtype">EStagingContentRequestStatus</td>          <td class="paramname"><span class="paramname"><em>Status</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="structFAccelByteModelsUGCPaginatedListStagingContentResponse.html">FAccelByteModelsUGCPaginatedListStagingContentResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Limit</em><span class="paramdefsep"> = </span><span class="paramdefval">20</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Offset</em><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EAccelByteStagingContentUtilitiesSortBy</td>          <td class="paramname"><span class="paramname"><em>SortBy</em><span class="paramdefsep"> = </span><span class="paramdefval">EAccelByteStagingContentUtilitiesSortBy::NONE</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a list of staging contents and sort by status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Status</td><td>Sort the response item by status of the staging list contents </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is FAccelByteModelsPaginatedListStagingContentResponse. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
    <tr><td class="paramname">Limit</td><td>Number of content per page. Default value : 20 </td></tr>
    <tr><td class="paramname">Offset</td><td>The offset number to retrieve. Default value : 0 </td></tr>
    <tr><td class="paramname">SortBy</td><td>Sorting criteria: created time with asc or desc and updated time with asc or desc. default = none. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab2237fd43368c8b8d87ff386555b482f" name="ab2237fd43368c8b8d87ff386555b482f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2237fd43368c8b8d87ff386555b482f">&#9670;&#160;</a></span>GetTags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::UGC::GetTags </td>
          <td>(</td>
          <td class="paramtype">THandler&lt; <a class="el" href="structFAccelByteModelsUGCTagsPagingResponse.html">FAccelByteModelsUGCTagsPagingResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Limit</em><span class="paramdefsep"> = </span><span class="paramdefval">1000</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Offset</em><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all tags. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is <a class="el" href="structFAccelByteModelsUGCTagsPagingResponse.html">FAccelByteModelsUGCTagsPagingResponse</a>. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
    <tr><td class="paramname">Limit</td><td>The limit of the tags results. Default value is 1000. </td></tr>
    <tr><td class="paramname">Offset</td><td>The offset of the tags results. Default value is 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a924a3dc5109d08ef581df907d64dbe74" name="a924a3dc5109d08ef581df907d64dbe74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a924a3dc5109d08ef581df907d64dbe74">&#9670;&#160;</a></span>GetTypes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::UGC::GetTypes </td>
          <td>(</td>
          <td class="paramtype">THandler&lt; <a class="el" href="structFAccelByteModelsUGCTypesPagingResponse.html">FAccelByteModelsUGCTypesPagingResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Limit</em><span class="paramdefsep"> = </span><span class="paramdefval">1000</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Offset</em><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all types and subtypes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is <a class="el" href="structFAccelByteModelsUGCTypesPagingResponse.html">FAccelByteModelsUGCTypesPagingResponse</a>. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
    <tr><td class="paramname">Limit</td><td>The limit of the types and subtypes results. Default value is 1000. </td></tr>
    <tr><td class="paramname">Offset</td><td>The offset of the types and subtypes results. Default value is 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a07b3af8b155767c6f49768121fdc7b89" name="a07b3af8b155767c6f49768121fdc7b89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07b3af8b155767c6f49768121fdc7b89">&#9670;&#160;</a></span>GetUserContent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::UGC::GetUserContent </td>
          <td>(</td>
          <td class="paramtype">const FString &amp;</td>          <td class="paramname"><span class="paramname"><em>UserId</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="structFAccelByteModelsUGCContentPageResponse.html">FAccelByteModelsUGCContentPageResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Limit</em><span class="paramdefsep"> = </span><span class="paramdefval">1000</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Offset</em><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get user's generated contents. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">UserId</td><td><a class="el" href="classAccelByte_1_1Api_1_1User.html" title="User management API for creating user, verifying user, and resetting password.">User</a> Id </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
    <tr><td class="paramname">Limit</td><td>Number of content per page. Default value : 1000 </td></tr>
    <tr><td class="paramname">Offset</td><td>The offset number to retrieve. Default value : 0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a33b9bfcd528d15adf43788d4407a43c0" name="a33b9bfcd528d15adf43788d4407a43c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33b9bfcd528d15adf43788d4407a43c0">&#9670;&#160;</a></span>GetUserContentsV2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::UGC::GetUserContentsV2 </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>UserId</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="structFAccelByteModelsUGCSearchContentsPagingResponseV2.html">FAccelByteModelsUGCSearchContentsPagingResponseV2</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Limit</em><span class="paramdefsep"> = </span><span class="paramdefval">20</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Offset</em><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EAccelByteUGCContentUtilitiesSortByV2</td>          <td class="paramname"><span class="paramname"><em>SortBy</em><span class="paramdefsep"> = </span><span class="paramdefval">EAccelByteUGCContentUtilitiesSortByV2::CREATED_TIME_DESC</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get user's generated contents. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">UserId</td><td><a class="el" href="classAccelByte_1_1Api_1_1User.html" title="User management API for creating user, verifying user, and resetting password.">User</a> Id </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is <a class="el" href="structFAccelByteModelsUGCSearchContentsPagingResponseV2.html">FAccelByteModelsUGCSearchContentsPagingResponseV2</a>. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
    <tr><td class="paramname">Limit</td><td>Number of content per page. Default value : 20 </td></tr>
    <tr><td class="paramname">Offset</td><td>The offset number to retrieve. Default value : 0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9361686cc3672d828f0f5fecbce2a827" name="a9361686cc3672d828f0f5fecbce2a827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9361686cc3672d828f0f5fecbce2a827">&#9670;&#160;</a></span>ModifyContent() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::UGC::ModifyContent </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ChannelId</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ContentId</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structFAccelByteModelsUGCRequest.html">FAccelByteModelsUGCRequest</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>UGCRequest</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="structFAccelByteModelsUGCResponse.html">FAccelByteModelsUGCResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>bUpdateContent</em><span class="paramdefsep"> = </span><span class="paramdefval">false</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modify existing content to update some information with FString preview. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ChannelId</td><td>The id of the content's channel. </td></tr>
    <tr><td class="paramname">ContentId</td><td>The id of the content that will be modified. </td></tr>
    <tr><td class="paramname">UGCRequest</td><td>Detail information for the content request that will be modified. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is <a class="el" href="structFAccelByteModelsUGCResponse.html">FAccelByteModelsUGCResponse</a>. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
    <tr><td class="paramname">bUpdateContent</td><td>This will be used to update the content too or only content information . Default value is false.</td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated</a></b></dt><dd>This method will be removed in the future, so please use void <a class="el" href="#af5777743df8b7caec13600e3c2887bea" title="Modify existing content to update some information with FString preview.">ModifyContent(FString const&amp; ChannelId
 , FString const&amp; ContentId
 , FAccelByteModelsUGCUpdateRequest const&amp; ModifyRequest
 , THandler&lt;FAccelByteModelsUGCResponse&gt; const&amp; OnSuccess
 , FErrorHandler const&amp; OnError)</a>; </dd></dl>

</div>
</div>
<a id="af5777743df8b7caec13600e3c2887bea" name="af5777743df8b7caec13600e3c2887bea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5777743df8b7caec13600e3c2887bea">&#9670;&#160;</a></span>ModifyContent() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::UGC::ModifyContent </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ChannelId</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ContentId</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structFAccelByteModelsUGCUpdateRequest.html">FAccelByteModelsUGCUpdateRequest</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>ModifyRequest</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="structFAccelByteModelsUGCResponse.html">FAccelByteModelsUGCResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modify existing content to update some information with FString preview. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ChannelId</td><td>The id of the content's channel. </td></tr>
    <tr><td class="paramname">ContentId</td><td>The id of the content that will be modified. </td></tr>
    <tr><td class="paramname">ModifyRequest</td><td>Detail information for the content request that will be modified. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is <a class="el" href="structFAccelByteModelsUGCResponse.html">FAccelByteModelsUGCResponse</a>. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afdc2d804b418e4707b23a6a6d61d665f" name="afdc2d804b418e4707b23a6a6d61d665f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdc2d804b418e4707b23a6a6d61d665f">&#9670;&#160;</a></span>ModifyContent() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::UGC::ModifyContent </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ChannelId</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ContentId</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>Name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>Type</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>SubType</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TArray&lt; FString &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>Tags</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TArray&lt; uint8 &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>Preview</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>FileExtension</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="structFAccelByteModelsUGCResponse.html">FAccelByteModelsUGCResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString</td>          <td class="paramname"><span class="paramname"><em>ContentType</em><span class="paramdefsep"> = </span><span class="paramdefval">TEXT(&quot;application/octet-stream&quot;)</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>bUpdateContent</em><span class="paramdefsep"> = </span><span class="paramdefval">false</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modify existing content to update some information with TArray&lt;uint8&gt; Preview parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ChannelId</td><td>The id of the content's channel. </td></tr>
    <tr><td class="paramname">ContentId</td><td>The id of the content that will be modified. </td></tr>
    <tr><td class="paramname">Name</td><td>Name of the content. </td></tr>
    <tr><td class="paramname">Type</td><td>Type of the content. </td></tr>
    <tr><td class="paramname">SubType</td><td>SubType of the content. </td></tr>
    <tr><td class="paramname">Tags</td><td>Tags of the content. </td></tr>
    <tr><td class="paramname">Preview</td><td>The TArray&lt;uint8&gt; of the content's Preview </td></tr>
    <tr><td class="paramname">FileExtension</td><td>FileExtension of the content. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is <a class="el" href="structFAccelByteModelsUGCResponse.html">FAccelByteModelsUGCResponse</a>. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
    <tr><td class="paramname">ContentType</td><td>The specific type of the content's modified. Default value is "application/octet-stream". </td></tr>
    <tr><td class="paramname">bUpdateContent</td><td>This will be used to update the content too or only content information . Default value is false.</td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000004">Deprecated</a></b></dt><dd>This method will be removed in the future, so please use void <a class="el" href="#af5777743df8b7caec13600e3c2887bea" title="Modify existing content to update some information with FString preview.">ModifyContent(FString const&amp; ChannelId
 , FString const&amp; ContentId
 , FAccelByteModelsUGCUpdateRequest const&amp; ModifyRequest
 , THandler&lt;FAccelByteModelsUGCResponse&gt; const&amp; OnSuccess
 , FErrorHandler const&amp; OnError)</a>; </dd></dl>

</div>
</div>
<a id="ace8d10aa216243bd045a29e09a97d62d" name="ace8d10aa216243bd045a29e09a97d62d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace8d10aa216243bd045a29e09a97d62d">&#9670;&#160;</a></span>ModifyContentByShareCode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::UGC::ModifyContentByShareCode </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ChannelId</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ShareCode</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structFAccelByteModelsUGCUpdateRequest.html">FAccelByteModelsUGCUpdateRequest</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>ModifyRequest</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="structFAccelByteModelsUGCResponse.html">FAccelByteModelsUGCResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modify existing content to update some information by share code. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ChannelId</td><td>The id of the content's channel. </td></tr>
    <tr><td class="paramname">ShareCode</td><td>The share code of the content that will be fetched. </td></tr>
    <tr><td class="paramname">ModifyRequest</td><td>Detail information for the content request that will be modified. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is <a class="el" href="structFAccelByteModelsUGCResponse.html">FAccelByteModelsUGCResponse</a>. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a29365c371ac4244701c3c7ce5426cfa4" name="a29365c371ac4244701c3c7ce5426cfa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29365c371ac4244701c3c7ce5426cfa4">&#9670;&#160;</a></span>ModifyContentShareCode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::UGC::ModifyContentShareCode </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ChannelId</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ContentId</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structFAccelByteModelsUGCModifyContentShareCodeRequest.html">FAccelByteModelsUGCModifyContentShareCodeRequest</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>ModifyContentShareCodeRequest</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="structFAccelByteModelsUGCResponse.html">FAccelByteModelsUGCResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modify the shareCode of a content. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ChannelId</td><td>The id of the content's channel. </td></tr>
    <tr><td class="paramname">ContentId</td><td>Content Id. </td></tr>
    <tr><td class="paramname">ModifyContentShareCodeRequest</td><td>Detail information for the content request that will be modified. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is <a class="el" href="structFAccelByteModelsUGCResponse.html">FAccelByteModelsUGCResponse</a>. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3a38b7b8a1a4812d616fb562729709fc" name="a3a38b7b8a1a4812d616fb562729709fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a38b7b8a1a4812d616fb562729709fc">&#9670;&#160;</a></span>ModifyContentShareCodeV2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::UGC::ModifyContentShareCodeV2 </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ChannelId</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ContentId</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structFAccelByteModelsUGCModifyContentShareCodeRequest.html">FAccelByteModelsUGCModifyContentShareCodeRequest</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>ModifyContentShareCodeRequest</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="structFAccelByteModelsUGCCreateUGCResponseV2.html">FAccelByteModelsUGCCreateUGCResponseV2</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modify the shareCode of a content. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ChannelId</td><td>The id of the content's channel. </td></tr>
    <tr><td class="paramname">ContentId</td><td>Content Id. </td></tr>
    <tr><td class="paramname">ModifyContentShareCodeRequest</td><td>Detail information for the content request that will be modified. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is <a class="el" href="structFAccelByteModelsUGCCreateUGCResponseV2.html">FAccelByteModelsUGCCreateUGCResponseV2</a>. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a59ced8b637d45f03c9f41d838a1d4d12" name="a59ced8b637d45f03c9f41d838a1d4d12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59ced8b637d45f03c9f41d838a1d4d12">&#9670;&#160;</a></span>ModifyContentV2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::UGC::ModifyContentV2 </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ChannelId</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ContentId</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structFAccelByteModelsModifyUGCRequestV2.html">FAccelByteModelsModifyUGCRequestV2</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>ModifyRequest</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="structFAccelByteModelsUGCModifyUGCResponseV2.html">FAccelByteModelsUGCModifyUGCResponseV2</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modify existing content to update content metadata. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ChannelId</td><td>The id of the content's channel. </td></tr>
    <tr><td class="paramname">ContentId</td><td>The id of the content. </td></tr>
    <tr><td class="paramname">ModifyRequest</td><td>Detail information for the content request that will be modified. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is <a class="el" href="structFAccelByteModelsUGCModifyUGCResponseV2.html">FAccelByteModelsUGCModifyUGCResponseV2</a>. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa287172c58f70b3c5ac338607a647d67" name="aa287172c58f70b3c5ac338607a647d67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa287172c58f70b3c5ac338607a647d67">&#9670;&#160;</a></span>PublicGetContentBulk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::UGC::PublicGetContentBulk </td>
          <td>(</td>
          <td class="paramtype">const TArray&lt; FString &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ContentIds</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; TArray&lt; <a class="el" href="structFAccelByteModelsUGCContentResponse.html">FAccelByteModelsUGCContentResponse</a> &gt; &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get contents by content Ids. Can be used without logged in. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ContentIds</td><td>Content Ids Array <br  />
 </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad7c656d74549380e47c50e6b96f01017" name="ad7c656d74549380e47c50e6b96f01017"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7c656d74549380e47c50e6b96f01017">&#9670;&#160;</a></span>PublicGetContentBulkByIdsV2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::UGC::PublicGetContentBulkByIdsV2 </td>
          <td>(</td>
          <td class="paramtype">TArray&lt; FString &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>ContentIds</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; TArray&lt; <a class="el" href="structFAccelByteModelsUGCContentResponseV2.html">FAccelByteModelsUGCContentResponseV2</a> &gt; &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get contents by content Ids. Can be used without logged in. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ContentIds</td><td>Content Ids Array </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is TArray&lt;FAccelByteModelsUGCContentResponseV2&gt;. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a09af8284b1d56eaa5318c1e89b8b4cee" name="a09af8284b1d56eaa5318c1e89b8b4cee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09af8284b1d56eaa5318c1e89b8b4cee">&#9670;&#160;</a></span>PublicGetContentByContentId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::UGC::PublicGetContentByContentId </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ContentId</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="structFAccelByteModelsUGCContentResponse.html">FAccelByteModelsUGCContentResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a content information by its content id. Can be used without logged in. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ContentId</td><td>The id of the content that will be fetched. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is <a class="el" href="structFAccelByteModelsUGCContentResponse.html">FAccelByteModelsUGCContentResponse</a>. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae6f4c21e3cdcf457ead5b19980c6449f" name="ae6f4c21e3cdcf457ead5b19980c6449f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6f4c21e3cdcf457ead5b19980c6449f">&#9670;&#160;</a></span>PublicGetContentByContentIdV2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::UGC::PublicGetContentByContentIdV2 </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ContentId</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="structFAccelByteModelsUGCContentResponseV2.html">FAccelByteModelsUGCContentResponseV2</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a content information by its content id. Can be used without logged in. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ContentId</td><td>The id of the content that will be fetched. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is <a class="el" href="structFAccelByteModelsUGCContentResponseV2.html">FAccelByteModelsUGCContentResponseV2</a>. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af7ac4204f3dd657187cef760ddf86493" name="af7ac4204f3dd657187cef760ddf86493"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7ac4204f3dd657187cef760ddf86493">&#9670;&#160;</a></span>PublicGetContentByShareCode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::UGC::PublicGetContentByShareCode </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ShareCode</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="structFAccelByteModelsUGCContentResponse.html">FAccelByteModelsUGCContentResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a content information by its share code. Can be used without logged in. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ShareCode</td><td>The share code of the content that will be fetched. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is <a class="el" href="structFAccelByteModelsUGCContentResponse.html">FAccelByteModelsUGCContentResponse</a>. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aadff241ffd9a9996af7ef3a019191573" name="aadff241ffd9a9996af7ef3a019191573"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadff241ffd9a9996af7ef3a019191573">&#9670;&#160;</a></span>PublicGetContentByShareCodeV2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::UGC::PublicGetContentByShareCodeV2 </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ShareCode</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="structFAccelByteModelsUGCContentResponseV2.html">FAccelByteModelsUGCContentResponseV2</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a content information by its share code. Can be used without logged in. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ShareCode</td><td>The share code of the content that will be fetched. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is <a class="el" href="structFAccelByteModelsUGCContentResponseV2.html">FAccelByteModelsUGCContentResponseV2</a>. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2b06508637e6eedcda19e7ec2cfe48f3" name="a2b06508637e6eedcda19e7ec2cfe48f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b06508637e6eedcda19e7ec2cfe48f3">&#9670;&#160;</a></span>PublicGetUserContent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::UGC::PublicGetUserContent </td>
          <td>(</td>
          <td class="paramtype">const FString &amp;</td>          <td class="paramname"><span class="paramname"><em>UserId</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="structFAccelByteModelsUGCContentPageResponse.html">FAccelByteModelsUGCContentPageResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Limit</em><span class="paramdefsep"> = </span><span class="paramdefval">1000</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Offset</em><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get user's generated contents. Can be used without logged in. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">UserId</td><td><a class="el" href="classAccelByte_1_1Api_1_1User.html" title="User management API for creating user, verifying user, and resetting password.">User</a> Id </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
    <tr><td class="paramname">Limit</td><td>Number of content per page. Default value : 1000 </td></tr>
    <tr><td class="paramname">Offset</td><td>The offset number to retrieve. Default value : 0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5db3435857568c3b7b99db23dd5e7b56" name="a5db3435857568c3b7b99db23dd5e7b56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5db3435857568c3b7b99db23dd5e7b56">&#9670;&#160;</a></span>PublicGetUserContentsV2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::UGC::PublicGetUserContentsV2 </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>UserId</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="structFAccelByteModelsUGCSearchContentsPagingResponseV2.html">FAccelByteModelsUGCSearchContentsPagingResponseV2</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Limit</em><span class="paramdefsep"> = </span><span class="paramdefval">20</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Offset</em><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EAccelByteUGCContentUtilitiesSortByV2</td>          <td class="paramname"><span class="paramname"><em>SortBy</em><span class="paramdefsep"> = </span><span class="paramdefval">EAccelByteUGCContentUtilitiesSortByV2::CREATED_TIME_DESC</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get user's generated contents. Can be used without logged in. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">UserId</td><td><a class="el" href="classAccelByte_1_1Api_1_1User.html" title="User management API for creating user, verifying user, and resetting password.">User</a> Id </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is <a class="el" href="structFAccelByteModelsUGCSearchContentsPagingResponseV2.html">FAccelByteModelsUGCSearchContentsPagingResponseV2</a>. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
    <tr><td class="paramname">Limit</td><td>Number of content per page. Default value : 20 </td></tr>
    <tr><td class="paramname">Offset</td><td>The offset number to retrieve. Default value : 0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac6a980705fc7b788403099dbbb797581" name="ac6a980705fc7b788403099dbbb797581"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6a980705fc7b788403099dbbb797581">&#9670;&#160;</a></span>PublicSearchContents() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::UGC::PublicSearchContents </td>
          <td>(</td>
          <td class="paramtype">const FString &amp;</td>          <td class="paramname"><span class="paramname"><em>Name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FString &amp;</td>          <td class="paramname"><span class="paramname"><em>Creator</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FString &amp;</td>          <td class="paramname"><span class="paramname"><em>Type</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FString &amp;</td>          <td class="paramname"><span class="paramname"><em>Subtype</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TArray&lt; FString &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Tags</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>IsOfficial</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FString &amp;</td>          <td class="paramname"><span class="paramname"><em>UserId</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="structFAccelByteModelsUGCSearchContentsPagingResponse.html">FAccelByteModelsUGCSearchContentsPagingResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EAccelByteUgcSortBy</td>          <td class="paramname"><span class="paramname"><em>SortBy</em><span class="paramdefsep"> = </span><span class="paramdefval">EAccelByteUgcSortBy::DATE</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EAccelByteUgcOrderBy</td>          <td class="paramname"><span class="paramname"><em>OrderBy</em><span class="paramdefsep"> = </span><span class="paramdefval">EAccelByteUgcOrderBy::DESC</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Limit</em><span class="paramdefsep"> = </span><span class="paramdefval">1000</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Offset</em><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search specific contents based on the given filter. Can be used without logged in. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Name</td><td>Content Name. </td></tr>
    <tr><td class="paramname">Creator</td><td>Creator Name. </td></tr>
    <tr><td class="paramname">Type</td><td>Content Type. </td></tr>
    <tr><td class="paramname">Subtype</td><td>Content Subtype. </td></tr>
    <tr><td class="paramname">Tags</td><td>Content Tags. </td></tr>
    <tr><td class="paramname">IsOfficial</td><td>Filter only official contents </td></tr>
    <tr><td class="paramname">UserId</td><td><a class="el" href="classAccelByte_1_1Api_1_1User.html" title="User management API for creating user, verifying user, and resetting password.">User</a> Id </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
    <tr><td class="paramname">SortBy</td><td>Sorting criteria, name,download,like,date. default=date. </td></tr>
    <tr><td class="paramname">OrderBy</td><td>Sorting order: asc, desc. default=desc </td></tr>
    <tr><td class="paramname">Limit</td><td>Number of content per page. Default value : 1000 </td></tr>
    <tr><td class="paramname">Offset</td><td>The offset number to retrieve. Default value : 0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac87ddff889bfdb2e2d9d0d2f0b986e8b" name="ac87ddff889bfdb2e2d9d0d2f0b986e8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac87ddff889bfdb2e2d9d0d2f0b986e8b">&#9670;&#160;</a></span>PublicSearchContents() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::UGC::PublicSearchContents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFAccelByteModelsUGCSearchContentsRequest.html">FAccelByteModelsUGCSearchContentsRequest</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>Request</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="structFAccelByteModelsUGCSearchContentsPagingResponse.html">FAccelByteModelsUGCSearchContentsPagingResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Limit</em><span class="paramdefsep"> = </span><span class="paramdefval">20</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Offset</em><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search specific contents based on the given filter. Can be used without logged in. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Request</td><td>Filter request to specify the search result. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
    <tr><td class="paramname">Limit</td><td>Number of content per page. Default value : 20 </td></tr>
    <tr><td class="paramname">Offset</td><td>The offset number to retrieve. Default value : 0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aefd109c2401f05ef150742bd1323043c" name="aefd109c2401f05ef150742bd1323043c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefd109c2401f05ef150742bd1323043c">&#9670;&#160;</a></span>PublicSearchContentsSpecificToChannelV2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::UGC::PublicSearchContentsSpecificToChannelV2 </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ChannelId</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="structFAccelByteModelsUGCSearchContentsPagingResponseV2.html">FAccelByteModelsUGCSearchContentsPagingResponseV2</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Limit</em><span class="paramdefsep"> = </span><span class="paramdefval">20</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Offset</em><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EAccelByteUGCContentUtilitiesSortByV2</td>          <td class="paramname"><span class="paramname"><em>SortBy</em><span class="paramdefsep"> = </span><span class="paramdefval">EAccelByteUGCContentUtilitiesSortByV2::CREATED_TIME_DESC</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search contents specific to a channel. Can be used without logged in. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ChannelId</td><td>Channel Id. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is <a class="el" href="structFAccelByteModelsUGCSearchContentsPagingResponseV2.html">FAccelByteModelsUGCSearchContentsPagingResponseV2</a>. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
    <tr><td class="paramname">Limit</td><td>Number of content per page. Default value : 20 </td></tr>
    <tr><td class="paramname">Offset</td><td>The offset number to retrieve. Default value : 0 </td></tr>
    <tr><td class="paramname">SortBy</td><td>Sorting criteria: created time with asc or desc. default = created time and desc. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac126d3b3aaed93384385f9220e629e98" name="ac126d3b3aaed93384385f9220e629e98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac126d3b3aaed93384385f9220e629e98">&#9670;&#160;</a></span>PublicSearchContentsV2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::UGC::PublicSearchContentsV2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFAccelByteModelsUGCFilterRequestV2.html">FAccelByteModelsUGCFilterRequestV2</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>Filter</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="structFAccelByteModelsUGCSearchContentsPagingResponseV2.html">FAccelByteModelsUGCSearchContentsPagingResponseV2</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Limit</em><span class="paramdefsep"> = </span><span class="paramdefval">20</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Offset</em><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EAccelByteUGCContentSortByV2</td>          <td class="paramname"><span class="paramname"><em>SortBy</em><span class="paramdefsep"> = </span><span class="paramdefval">EAccelByteUGCContentSortByV2::CREATED_TIME_DESC</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all contents in current namespace. Can be used without logged in. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Filter</td><td>To filter the returned <a class="el" href="classAccelByte_1_1Api_1_1UGC.html" title="Provide APIs to access UGC service.">UGC</a> contets. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is <a class="el" href="structFAccelByteModelsUGCSearchContentsPagingResponseV2.html">FAccelByteModelsUGCSearchContentsPagingResponseV2</a>. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
    <tr><td class="paramname">Limit</td><td>Number of content per page. Default value : 20 </td></tr>
    <tr><td class="paramname">Offset</td><td>The offset number to retrieve. Default value : 0 </td></tr>
    <tr><td class="paramname">SortBy</td><td>Sorting criteria: name, download, like, created time with asc or desc. default = created time and desc. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae3063ff832866492c4e3b0ccb4c4faef" name="ae3063ff832866492c4e3b0ccb4c4faef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3063ff832866492c4e3b0ccb4c4faef">&#9670;&#160;</a></span>SearchContents() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::UGC::SearchContents </td>
          <td>(</td>
          <td class="paramtype">const FString &amp;</td>          <td class="paramname"><span class="paramname"><em>Name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FString &amp;</td>          <td class="paramname"><span class="paramname"><em>Creator</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FString &amp;</td>          <td class="paramname"><span class="paramname"><em>Type</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FString &amp;</td>          <td class="paramname"><span class="paramname"><em>Subtype</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TArray&lt; FString &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Tags</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>IsOfficial</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FString &amp;</td>          <td class="paramname"><span class="paramname"><em>UserId</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="structFAccelByteModelsUGCSearchContentsPagingResponse.html">FAccelByteModelsUGCSearchContentsPagingResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EAccelByteUgcSortBy</td>          <td class="paramname"><span class="paramname"><em>SortBy</em><span class="paramdefsep"> = </span><span class="paramdefval">EAccelByteUgcSortBy::DATE</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EAccelByteUgcOrderBy</td>          <td class="paramname"><span class="paramname"><em>OrderBy</em><span class="paramdefsep"> = </span><span class="paramdefval">EAccelByteUgcOrderBy::DESC</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Limit</em><span class="paramdefsep"> = </span><span class="paramdefval">1000</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Offset</em><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search specific contents based on the given filter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Name</td><td>Content Name. </td></tr>
    <tr><td class="paramname">Creator</td><td>Creator Name. </td></tr>
    <tr><td class="paramname">Type</td><td>Content Type. </td></tr>
    <tr><td class="paramname">Subtype</td><td>Content Subtype. </td></tr>
    <tr><td class="paramname">Tags</td><td>Content Tags. </td></tr>
    <tr><td class="paramname">IsOfficial</td><td>Filter only official contents </td></tr>
    <tr><td class="paramname">UserId</td><td><a class="el" href="classAccelByte_1_1Api_1_1User.html" title="User management API for creating user, verifying user, and resetting password.">User</a> Id </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
    <tr><td class="paramname">SortBy</td><td>Sorting criteria, name,download,like,date. default=date. </td></tr>
    <tr><td class="paramname">OrderBy</td><td>Sorting order: asc, desc. default=desc </td></tr>
    <tr><td class="paramname">Limit</td><td>Number of content per page. Default value : 1000 </td></tr>
    <tr><td class="paramname">Offset</td><td>The offset number to retrieve. Default value : 0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a30e7d643b2d73f4a7503811986d73220" name="a30e7d643b2d73f4a7503811986d73220"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30e7d643b2d73f4a7503811986d73220">&#9670;&#160;</a></span>SearchContents() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::UGC::SearchContents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFAccelByteModelsUGCSearchContentsRequest.html">FAccelByteModelsUGCSearchContentsRequest</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>Request</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="structFAccelByteModelsUGCSearchContentsPagingResponse.html">FAccelByteModelsUGCSearchContentsPagingResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Limit</em><span class="paramdefsep"> = </span><span class="paramdefval">20</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Offset</em><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search specific contents based on the given filter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Request</td><td>Filter request to specify the search result. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
    <tr><td class="paramname">Limit</td><td>Number of content per page. Default value : 20 </td></tr>
    <tr><td class="paramname">Offset</td><td>The offset number to retrieve. Default value : 0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9cca87c6528d665d51ab7ab2855dac99" name="a9cca87c6528d665d51ab7ab2855dac99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cca87c6528d665d51ab7ab2855dac99">&#9670;&#160;</a></span>SearchContentsSpecificToChannel() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::UGC::SearchContentsSpecificToChannel </td>
          <td>(</td>
          <td class="paramtype">const FString &amp;</td>          <td class="paramname"><span class="paramname"><em>ChannelId</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FString &amp;</td>          <td class="paramname"><span class="paramname"><em>Name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FString &amp;</td>          <td class="paramname"><span class="paramname"><em>Creator</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FString &amp;</td>          <td class="paramname"><span class="paramname"><em>Type</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FString &amp;</td>          <td class="paramname"><span class="paramname"><em>Subtype</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TArray&lt; FString &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Tags</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>IsOfficial</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FString &amp;</td>          <td class="paramname"><span class="paramname"><em>UserId</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="structFAccelByteModelsUGCSearchContentsPagingResponse.html">FAccelByteModelsUGCSearchContentsPagingResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EAccelByteUgcSortBy</td>          <td class="paramname"><span class="paramname"><em>SortBy</em><span class="paramdefsep"> = </span><span class="paramdefval">EAccelByteUgcSortBy::DATE</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EAccelByteUgcOrderBy</td>          <td class="paramname"><span class="paramname"><em>OrderBy</em><span class="paramdefsep"> = </span><span class="paramdefval">EAccelByteUgcOrderBy::DESC</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Limit</em><span class="paramdefsep"> = </span><span class="paramdefval">1000</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Offset</em><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search contents specific to a channel. <br  />
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ChannelId</td><td>Channel Id. </td></tr>
    <tr><td class="paramname">Name</td><td>Content Name. </td></tr>
    <tr><td class="paramname">Creator</td><td>Creator Name. </td></tr>
    <tr><td class="paramname">Type</td><td>Content Type. </td></tr>
    <tr><td class="paramname">Subtype</td><td>Content Subtype. </td></tr>
    <tr><td class="paramname">Tags</td><td>Content Tags. </td></tr>
    <tr><td class="paramname">IsOfficial</td><td>Filter only official contents </td></tr>
    <tr><td class="paramname">UserId</td><td><a class="el" href="classAccelByte_1_1Api_1_1User.html" title="User management API for creating user, verifying user, and resetting password.">User</a> Id </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
    <tr><td class="paramname">SortBy</td><td>Sorting criteria, name,download,like,date. default=date. </td></tr>
    <tr><td class="paramname">OrderBy</td><td>Sorting order: asc, desc. default=desc </td></tr>
    <tr><td class="paramname">Limit</td><td>Number of content per page. Default value : 1000 </td></tr>
    <tr><td class="paramname">Offset</td><td>The offset number to retrieve. Default value : 0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3b52538045aecada33275e0bee56a5c6" name="a3b52538045aecada33275e0bee56a5c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b52538045aecada33275e0bee56a5c6">&#9670;&#160;</a></span>SearchContentsSpecificToChannel() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::UGC::SearchContentsSpecificToChannel </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ChannelId</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structFAccelByteModelsUGCSearchContentsRequest.html">FAccelByteModelsUGCSearchContentsRequest</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>Request</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="structFAccelByteModelsUGCSearchContentsPagingResponse.html">FAccelByteModelsUGCSearchContentsPagingResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Limit</em><span class="paramdefsep"> = </span><span class="paramdefval">20</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Offset</em><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search contents specific to a channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ChannelId</td><td>Channel Id. </td></tr>
    <tr><td class="paramname">Request</td><td>Filter request to specify the search result. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
    <tr><td class="paramname">Limit</td><td>Number of content per page. Default value : 1000 </td></tr>
    <tr><td class="paramname">Offset</td><td>The offset number to retrieve. Default value : 0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a77e73a112397ca7e936cb1fa0a67fcf7" name="a77e73a112397ca7e936cb1fa0a67fcf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77e73a112397ca7e936cb1fa0a67fcf7">&#9670;&#160;</a></span>SearchContentsSpecificToChannelV2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::UGC::SearchContentsSpecificToChannelV2 </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ChannelId</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="structFAccelByteModelsUGCSearchContentsPagingResponseV2.html">FAccelByteModelsUGCSearchContentsPagingResponseV2</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Limit</em><span class="paramdefsep"> = </span><span class="paramdefval">20</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Offset</em><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EAccelByteUGCContentUtilitiesSortByV2</td>          <td class="paramname"><span class="paramname"><em>SortBy</em><span class="paramdefsep"> = </span><span class="paramdefval">EAccelByteUGCContentUtilitiesSortByV2::CREATED_TIME_DESC</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search contents specific to a channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ChannelId</td><td>Channel Id. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is <a class="el" href="structFAccelByteModelsUGCSearchContentsPagingResponseV2.html">FAccelByteModelsUGCSearchContentsPagingResponseV2</a>. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
    <tr><td class="paramname">Limit</td><td>Number of content per page. Default value : 20 </td></tr>
    <tr><td class="paramname">Offset</td><td>The offset number to retrieve. Default value : 0 </td></tr>
    <tr><td class="paramname">SortBy</td><td>Sorting criteria: created time with asc or desc. default = created time and desc. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a175fcaf20c249740f82908c45a77aa25" name="a175fcaf20c249740f82908c45a77aa25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a175fcaf20c249740f82908c45a77aa25">&#9670;&#160;</a></span>SearchContentsV2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::UGC::SearchContentsV2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFAccelByteModelsUGCFilterRequestV2.html">FAccelByteModelsUGCFilterRequestV2</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>Filter</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="structFAccelByteModelsUGCSearchContentsPagingResponseV2.html">FAccelByteModelsUGCSearchContentsPagingResponseV2</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Limit</em><span class="paramdefsep"> = </span><span class="paramdefval">20</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32</td>          <td class="paramname"><span class="paramname"><em>Offset</em><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EAccelByteUGCContentSortByV2</td>          <td class="paramname"><span class="paramname"><em>SortBy</em><span class="paramdefsep"> = </span><span class="paramdefval">EAccelByteUGCContentSortByV2::CREATED_TIME_DESC</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all contents in current namespace. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Filter</td><td>To filter the returned <a class="el" href="classAccelByte_1_1Api_1_1UGC.html" title="Provide APIs to access UGC service.">UGC</a> contets. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is <a class="el" href="structFAccelByteModelsUGCSearchContentsPagingResponseV2.html">FAccelByteModelsUGCSearchContentsPagingResponseV2</a>. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
    <tr><td class="paramname">Limit</td><td>Number of content per page. Default value : 20 </td></tr>
    <tr><td class="paramname">Offset</td><td>The offset number to retrieve. Default value : 0 </td></tr>
    <tr><td class="paramname">SortBy</td><td>Sorting criteria: name, download, like, created time with asc or desc. default = created time and desc. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a39e5986744921b67750f8c2831908979" name="a39e5986744921b67750f8c2831908979"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39e5986744921b67750f8c2831908979">&#9670;&#160;</a></span>UpdateChannel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::UGC::UpdateChannel </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ChannelId</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ChannelName</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="structFAccelByteModelsUGCChannelResponse.html">FAccelByteModelsUGCChannelResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update a player's channel with specific channel name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ChannelId</td><td>The id of the channel that will be updated. </td></tr>
    <tr><td class="paramname">ChannelName</td><td>The name of the channel. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is <a class="el" href="structFAccelByteModelsUGCChannelResponse.html">FAccelByteModelsUGCChannelResponse</a>. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acf104b28ffdc3460fa08a7662d678fe5" name="acf104b28ffdc3460fa08a7662d678fe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf104b28ffdc3460fa08a7662d678fe5">&#9670;&#160;</a></span>UpdateContentFileLocationV2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::UGC::UpdateContentFileLocationV2 </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ChannelId</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ContentId</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>FileExtension</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>S3Key</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="structFAccelByteModelsUGCUpdateContentFileLocationResponseV2.html">FAccelByteModelsUGCUpdateContentFileLocationResponseV2</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update Content File Location in S3. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ChannelId</td><td>The id of the content's channel. </td></tr>
    <tr><td class="paramname">ContentId</td><td>The id of the content. </td></tr>
    <tr><td class="paramname">FileExtension</td><td>FileExtension of the content. </td></tr>
    <tr><td class="paramname">S3Key</td><td>Detail information about the file location in S3. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is <a class="el" href="structFAccelByteModelsUGCUpdateContentFileLocationResponseV2.html">FAccelByteModelsUGCUpdateContentFileLocationResponseV2</a>. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5162becebdf137f77bb189d6f1618c40" name="a5162becebdf137f77bb189d6f1618c40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5162becebdf137f77bb189d6f1618c40">&#9670;&#160;</a></span>UpdateContentScreenshotV2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::UGC::UpdateContentScreenshotV2 </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ContentId</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structFAccelByteModelsUGCUpdateScreenshotsV2.html">FAccelByteModelsUGCUpdateScreenshotsV2</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>ScreenshotsRequest</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="structFAccelByteModelsUGCUpdateScreenshotsV2.html">FAccelByteModelsUGCUpdateScreenshotsV2</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update screenshots for content. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ContentId</td><td>Content Id. </td></tr>
    <tr><td class="paramname">ScreenshotsRequest</td><td>Screenshots Request Supported file extensions: pjp, jpg, jpeg, jfif, bmp, png. Maximum description length: 1024. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is <a class="el" href="structFAccelByteModelsUGCUpdateScreenshotsV2.html">FAccelByteModelsUGCUpdateScreenshotsV2</a>. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af937490e74168b5a76dddf5ba74766f4" name="af937490e74168b5a76dddf5ba74766f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af937490e74168b5a76dddf5ba74766f4">&#9670;&#160;</a></span>UpdateFollowStatusToUser()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::UGC::UpdateFollowStatusToUser </td>
          <td>(</td>
          <td class="paramtype">const FString &amp;</td>          <td class="paramname"><span class="paramname"><em>UserId</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>bFollowStatus</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="structFAccelByteModelsUGCUpdateFollowStatusToUserResponse.html">FAccelByteModelsUGCUpdateFollowStatusToUserResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update follow/unfollow status to a user. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">UserId</td><td>The id of the user that will be updated. </td></tr>
    <tr><td class="paramname">bFollowStatus</td><td>The new follow status value. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3ae14e910608e33cdd75ffe314500e41" name="a3ae14e910608e33cdd75ffe314500e41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ae14e910608e33cdd75ffe314500e41">&#9670;&#160;</a></span>UpdateLikeStatusToContent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::UGC::UpdateLikeStatusToContent </td>
          <td>(</td>
          <td class="paramtype">const FString &amp;</td>          <td class="paramname"><span class="paramname"><em>ContentId</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>bLikeStatus</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="structFAccelByteModelsUGCUpdateLikeStatusToContentResponse.html">FAccelByteModelsUGCUpdateLikeStatusToContentResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update like/unlike status to a content. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ContentId</td><td>The content id that will be updated. </td></tr>
    <tr><td class="paramname">bLikeStatus</td><td>New like Status value. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abbcd58a827b41be6a2fc7f4309b720c9" name="abbcd58a827b41be6a2fc7f4309b720c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbcd58a827b41be6a2fc7f4309b720c9">&#9670;&#160;</a></span>UpdateLikeStatusToContentV2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::UGC::UpdateLikeStatusToContentV2 </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ContentId</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>bLikeStatus</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="structFAccelByteModelsUGCUpdateLikeStatusToContentResponse.html">FAccelByteModelsUGCUpdateLikeStatusToContentResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update like/unlike status to a content. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ContentId</td><td>The content id that will be updated. </td></tr>
    <tr><td class="paramname">bLikeStatus</td><td>New like Status value. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a61b36cb39b384dee2c19b79b358a6b28" name="a61b36cb39b384dee2c19b79b358a6b28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61b36cb39b384dee2c19b79b358a6b28">&#9670;&#160;</a></span>UpdateStagingContent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::UGC::UpdateStagingContent </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ContentId</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structFAccelByteModelsUGCUpdateContentFileLocationRequestV2.html">FAccelByteModelsUGCUpdateContentFileLocationRequestV2</a></td>          <td class="paramname"><span class="paramname"><em>UpdateRequest</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="structFAccelByteModelsUGCStagingContentResponse.html">FAccelByteModelsUGCStagingContentResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update staging content by content id using update request struct. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ContentId</td><td>Target content id to update the content </td></tr>
    <tr><td class="paramname">UpdateRequest</td><td>Query or params in struct to request an update </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is FAccelByteModelsStagingContentResponse. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a343386299199e87c311475f366f5bf02" name="a343386299199e87c311475f366f5bf02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a343386299199e87c311475f366f5bf02">&#9670;&#160;</a></span>UploadContentScreenshot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::UGC::UploadContentScreenshot </td>
          <td>(</td>
          <td class="paramtype">const FString &amp;</td>          <td class="paramname"><span class="paramname"><em>ContentId</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FString &amp;</td>          <td class="paramname"><span class="paramname"><em>UserId</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structFAccelByteModelsUGCScreenshotsRequest.html">FAccelByteModelsUGCScreenshotsRequest</a></td>          <td class="paramname"><span class="paramname"><em>ScreenshotsRequest</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="structFAccelByteModelsUGCUpdateContentScreenshotResponse.html">FAccelByteModelsUGCUpdateContentScreenshotResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Upload screenshots for content. <br  />
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ContentId</td><td>Content Id. </td></tr>
    <tr><td class="paramname">UserId</td><td><a class="el" href="classAccelByte_1_1Api_1_1User.html" title="User management API for creating user, verifying user, and resetting password.">User</a> Id </td></tr>
    <tr><td class="paramname">ScreenshotsRequest</td><td>Screenshots Request <br  />
 Supported file extensions: pjp, jpg, jpeg, jfif, bmp, png. Maximum description length: 1024. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4318fed2eeba415eeb027f247de7c44b" name="a4318fed2eeba415eeb027f247de7c44b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4318fed2eeba415eeb027f247de7c44b">&#9670;&#160;</a></span>UploadContentScreenshotV2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AccelByte::Api::UGC::UploadContentScreenshotV2 </td>
          <td>(</td>
          <td class="paramtype">FString const &amp;</td>          <td class="paramname"><span class="paramname"><em>ContentId</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structFAccelByteModelsUGCUploadScreenshotsRequestV2.html">FAccelByteModelsUGCUploadScreenshotsRequestV2</a> const &amp;</td>          <td class="paramname"><span class="paramname"><em>ScreenshotsRequest</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THandler&lt; <a class="el" href="structFAccelByteModelsUGCUpdateContentScreenshotResponse.html">FAccelByteModelsUGCUpdateContentScreenshotResponse</a> &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnSuccess</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FErrorHandler const &amp;</td>          <td class="paramname"><span class="paramname"><em>OnError</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Upload screenshots for content. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ContentId</td><td>Content Id. </td></tr>
    <tr><td class="paramname">ScreenshotsRequest</td><td>Screenshots Request. Supported file extensions: pjp, jpg, jpeg, jfif, bmp, png. Maximum description length: 1024. </td></tr>
    <tr><td class="paramname">OnSuccess</td><td>This will be called when the operation succeeded. The result is <a class="el" href="structFAccelByteModelsUGCUpdateContentScreenshotResponse.html">FAccelByteModelsUGCUpdateContentScreenshotResponse</a>. </td></tr>
    <tr><td class="paramname">OnError</td><td>This will be called when the operation failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>Source/AccelByteUe4Sdk/Public/Api/<a class="el" href="AccelByteUGCApi_8h_source.html">AccelByteUGCApi.h</a></li>
<li>Source/AccelByteUe4Sdk/Private/Api/<b>AccelByteUGCApi.cpp</b></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>AccelByte</b></li><li class="navelem"><a class="el" href="namespaceAccelByte_1_1Api.html">Api</a></li><li class="navelem"><a class="el" href="classAccelByte_1_1Api_1_1UGC.html">UGC</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0 </li>
  </ul>
</div>
</body>
</html>
